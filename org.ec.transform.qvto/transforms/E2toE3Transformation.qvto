import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');


// The plan is to take as input two uml models, and output another uml model 
transformation E2toE3Transformation(inout e2Model:uml, in fUmlModel:uml) 
	access EcTransformationLibrary;

configuration property CONNECTOR_CLS_MODEL_PATH : String;
configuration property OUTPORT_MULTIPLICITY : Integer;
configuration property ALF_PKG_NAME : String;

configuration property IFC_ASSOC_NAME : String;
configuration property LogIndentLevel : Integer;

helper checkConfigurationPropertyValues() {
			
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "OutPort";
		
	assert fatal (CONNECTOR_CLS_MODEL_PATH <> null) with 
		log("CONNECTOR_CLS_MODEL_PATH parameter is mandatory");
	
	assert fatal (OUTPORT_MULTIPLICITY <> null) with 
		log("OUTPORT_MULTIPLICITY parameter is mandatory");
				
	assert fatal (ALF_PKG_NAME <> null) with 
		log("ALF_PKG_NAME parameter is mandatory");
}


main() {
	initializeLogger();
	beginLog('Starting E2 to E3 transformation');

	// can we just write a huge helper function which will do all the manipulation? 
	transformE2toE3();
	
	endLog('Done');	
}

constructor Property::Property(nameArg:String, typeArg : Interface, 
							  lowerArg: Integer, upperArg: Integer) {
	name := nameArg;
	type := typeArg;
	lower := lowerArg;
	upper := upperArg;
}


// We are searching for an activity like name "xOp$method$1";
// and we want to skip names like destroy$method$1, ConnectorCls$method$1, 
// ConnectorCls$initialization$1... 
helper findConnectorBehaviorActivity(fUmlConCls: Class) : Activity {
														
	var behaviorSet : Set(Behavior) := fUmlConCls.ownedBehavior
		->select(name.indexOf(fUmlConCls.name +"$") <= 0 and 
				 name.indexOf("destroy" + "$") <= 0);
		
	assert fatal (behaviorSet->size() = 1) with 
		log("fUML class " + fUmlConCls.name + " has more than one activities for connector " + 
		    "behavior candidate!");	
		
	var fUmlConnectorBehaviorActivity : Activity := 
		behaviorSet->oclAsType(Activity)->asSequence()->at(1);
	
	return fUmlConnectorBehaviorActivity;
}


helper transformE2toE3()  {

	checkConfigurationPropertyValues();
	
	beginLog("Locating e2 model elements...");
	
	// now, let's locate the connector class inside the e2 model: 
	var e2ModelElt : Model := e2Model.rootObjects()[Model]->asSequence()->at(1);
	var allObjects : Set(Element) := e2Model.rootObjects()->oclAsType(Element)->asSet();
		
	var e2ConCls : Class := getModelElement(CONNECTOR_CLS_MODEL_PATH, e2Model)
		->oclAsType(Class)->asSequence()->at(1);
	assert fatal (e2ConCls <> null) with
		log("Could not find class " + CONNECTOR_CLS_MODEL_PATH + " in input model");
	
	var e2xIfc : Interface := getInterfaceFromConnectorCls(e2ConCls);
		
	endLog("Done");
	
	beginLog("Locating fUML model elements");
	
	// locate fUML model elements: ConnectorClass should be under the package named in alf 
	var fUmlModel : Model := fUmlModel.rootObjects()[Model]->asSequence()->at(1);
	
	var fUmlPkg : Package := fUmlModel.packagedElement
		->select(name = ALF_PKG_NAME)
		->oclAsType(Package)->asSequence()->at(1);
						      
	var fUmlConCls : Class := fUmlPkg.packagedElement
		->select(name = e2ConCls.name)->oclAsType(Class)->asSequence()->at(1);
														
	
	endLog("Done");

	var resolverSet : Set(NamedElement) := buildResolverSet(e2ConCls, e2xIfc);
	
	importClassBehaviorsFromFumlModel(e2ConCls, fUmlConCls, resolverSet);
}

helper importClassBehaviorsFromFumlModel(inout e2Cls : Class, inout fumlClass: Class, 
	in resolverSet : Set(NamedElement) )
{
	// Copy attributes of fUML class which does not exist in the e2 class:
	fumlClass.ownedAttribute->forEach(fUmlAttr)
	{
		if (e2Cls.ownedAttribute->select(name = fUmlAttr.name)->size() = 0)
		{
			e2Cls.ownedAttribute += fUmlAttr;
		}
	};
	
	// Transform operations under e2 class: 
	fumlClass.ownedOperation->forEach(fUmlOperation)
	{
		var opBehavior : Activity := fUmlOperation.method->oclAsType(Activity)->asSequence()->at(1);
		var theOperation : Operation := null;
		
		// Check if the operation exists in the e2 class: 
		if (e2Cls.ownedOperation->select(name = fUmlOperation.name)->size() <> 0)
		{
			var e2Op : Operation := 
				e2Cls.ownedOperation->select(name = fUmlOperation.name)
				->asSequence()->at(1);
			
			// Delete existing method of e2 operation;
			if (e2Op.method != null)
			{
				e2Model.removeElement(e2Op.method.oclAsType(Element)->asSequence()->at(1));
			};
			
			// Set specification of the newActivity to xOp in the e2 model. 
			opBehavior.specification := e2Op;
			theOperation := e2Op;
		}
		else
		{
			// move the operation into e2Cls
			e2Cls.ownedOperation += fUmlOperation;
			theOperation := fUmlOperation; 
		};
		
		// move operation behavior under e2class
		e2Cls.ownedBehavior += opBehavior;
		
		transformOperationBehavior(e2Cls, theOperation, opBehavior, resolverSet);
	};
	
	  
	// Do the same things for nested classes? 
	e2Cls.nestedClassifier->forEach(nestedE2Classifier)
	{
		var nesteE2Class : Class := nestedE2Classifier->oclAsType(Class)->asSequence()->at(1); 
		var fUmlNestedClass : Class := fumlClass.nestedClassifier->select(name = nesteE2Class.name)
			->oclAsType(Class)->asSequence()->at(1);
			
		assert fatal (fUmlNestedClass <> null) with log("No counterpart for the nested " + 
			"e2 model classifier " + nesteE2Class.name + " under fUML class " + fumlClass.name);
	
		importClassBehaviorsFromFumlModel(nesteE2Class, fUmlNestedClass, resolverSet);
	};
}

helper buildResolverSet(e2Cls : Class, e2Ifc : Interface) : Set(NamedElement)
{
	var resolverSet : Set(NamedElement);

	resolverSet += e2Cls;
	resolverSet += e2Ifc;
	
	var allStuff : Set(Element) := e2Cls[Class]->allOwnedElements()
		->asSequence()->at(1);
	 
	allStuff->forEach(e) {
		if (e->oclIsTypeOf(Class)->asSequence()->at(1) or
		    e->oclIsTypeOf(Property)->asSequence()->at(1) or  
		    e->oclIsTypeOf(Operation)->asSequence()->at(1) 
		)
		{
			resolverSet += e->oclAsType(NamedElement);
		}
	};
	 
	e2Ifc.ownedOperation->forEach(op) {
		resolverSet += op;
	};	
	
	 
	return resolverSet;
}

helper resolveUsingSet(resolverSet : Set(NamedElement), queryElement: NamedElement) : 
	NamedElement
{
	// First, try to make a plain name resolution: 
	var resultSet : Set(NamedElement) := resolverSet->select(name = queryElement.name);	
	if (resultSet->size() = 1)
	{
		return resultSet->asSequence()->at(1); 
	}
	else if (resultSet->size() = 0)
	{
		return null;
	};
	
	// Refine by metaclass: 
	resultSet := resultSet->select(metaClassName() = queryElement.metaClassName() );
	if (resultSet->size() = 1)
	{
		return resultSet->asSequence()->at(1); 
	}
	else if (resultSet->size() = 0)
	{
		return null;
	};
	
	// Refine by matching owner's of element:
	resultSet := resultSet->select(
			owner->oclAsType(NamedElement)->asSequence()->at(1).name = 
			queryElement.owner->oclAsType(NamedElement)->asSequence()->at(1).name);	
	if (resultSet->size() = 1)
	{
		return resultSet->asSequence()->at(1);
	};

	return null;
}

helper resolveTypeUsingSet(resolverSet : Set(NamedElement),	queryElement: NamedElement) : 
	Type
{
	var ne : NamedElement := resolveUsingSet(resolverSet, queryElement);
	
	if (ne <> null)
	{
		return ne->oclAsType(Type)->asSequence()->at(1);
	}
	else
	{
		return null;
	}
}

helper resolveClassUsingSet(resolverSet : Set(NamedElement), queryElement: NamedElement) : 
	Class
{
	var ne : NamedElement := resolveUsingSet(resolverSet, queryElement);
	
	if (ne <> null)
	{
		return ne->oclAsType(Class)->asSequence()->at(1);
	}
	else
	{
		return null;
	}
}


helper resolvePropertyUsingSet(resolverSet : Set(NamedElement),	queryElement: NamedElement) : 
	Property
{
	var ne : NamedElement := resolveUsingSet(resolverSet, queryElement);
	
	if (ne <> null)
	{
		return ne->oclAsType(Property)->asSequence()->at(1);
	}
	else
	{
		return null;
	}
}

helper resolveOperationUsingSet(resolverSet : Set(NamedElement), queryElement: NamedElement) : 
	Operation
{
	var ne : NamedElement := resolveUsingSet(resolverSet, queryElement);
	
	if (ne <> null)
	{
		return ne->oclAsType(Operation)->asSequence()->at(1);
	}
	else
	{
		return null;
	}
}


// Copy given fUmlActivity into given e2Cls class, 
// e2xOp will be the specification of the new activity 
// and new activity will be the method of operation e2xOp. 
// e2Ifc will be replaced with its e2Ifc counterparts
// if found in fUmlActivity 
helper transformOperationBehavior(
	inout e2Cls: Class, 
	inout e2xOp : Operation,
	in fUmlActivity: Activity, 
	in resolverSet : Set(NamedElement) )
{
	var count : Integer := 0;
	
	beginLog("Fixing unresolved references of connector behavior activity " +  
		fUmlActivity.qualifiedName);
	
	e2xOp.ownedParameter->forEach(param) {
	
		var qualName : String := param.type.qualifiedName;
		
		if (qualName.indexOf(ALF_PKG_NAME) > 0)
		{
			inlog("Found parameter: " + param.name);
			
			var type : Type := resolveTypeUsingSet(resolverSet, param.type);
			
			if (type <> null)
			{
				inlog("Updating type field of parameter " + param.name + " as " + type.name);
				param.type := type;
				count := count + 1;	
			}
			else
			{
				inlog("WARNING #16: could not resolve parameter type: " + param.type.name);
			};
		}
	};
	
	var allStuff : Set(Element) := fUmlActivity[Activity]->allOwnedElements()
		->asSequence()->at(1);
	 
	allStuff->forEach(e) {
		
		if (e.oclIsKindOf(StructuralFeatureAction))
		{
			var sfa : StructuralFeatureAction = e.oclAsType(StructuralFeatureAction);
			
			var sfqualifiedName : String := sfa.structuralFeature.qualifiedName;
			
			var idx : Integer := sfqualifiedName.indexOf(ALF_PKG_NAME);  
			if (idx > 0)
			{
				inlog("Found: StructuralFeatureAction: " + sfa.qualifiedName);
				count := count + 1; 	

				var foundCount : Integer := 
					resolveUsingSet(resolverSet, sfa.structuralFeature)->size();
				
				if (foundCount != 1)
				{ 
					inlog("WARNING #1: Expected to find exactly 1 attribute with name " + 
						sfa.structuralFeature.name +  
						" under class " + e2Cls.qualifiedName  + " but found " + 
						foundCount.toString());
				}
				else
				{
					var e2Property : Property := 
						resolvePropertyUsingSet(resolverSet, sfa.structuralFeature); 
					
					// Now, let's alter the structural feature to this one. 
					sfa.structuralFeature := e2Property;
					inlog("Updated structuralFeature field of StructuralFeatureAction " + 
						sfa.qualifiedName);
					count := count + 1;
				};
				
				
				
				var sfaObjectTypeQualName : String := sfa._object.type.qualifiedName;
				
				idx := sfaObjectTypeQualName.indexOf(ALF_PKG_NAME);
				if (idx > 0)
				{
					inlog("Found StructuralFeatureAction object: " + sfa._object.qualifiedName);
					var type : Type := resolveTypeUsingSet(resolverSet, sfa._object.type);
						
					if (type <> null)
					{
						inlog("Updating object.type field of StructuralFeatureAction " + 
							sfa.qualifiedName + " as " + type.name);
						sfa._object.type := type;
						count := count + 1;
					}
					else
					{
						inlog("WARNING #2: don't know what to do with unknown " + 
							"StructuralFeatureAction object.type: " + sfaObjectTypeQualName);
					}
				};  
				
				var outputPin : OutputPin := null;
				
				if (sfa->oclIsTypeOf(ReadStructuralFeatureAction)->asSequence()->at(1))
				{
					var tmp : ReadStructuralFeatureAction :=
						sfa->oclAsType(ReadStructuralFeatureAction)->asSequence()
						->at(1);
					outputPin := tmp._result;
				}
				else if (sfa->oclIsTypeOf(WriteStructuralFeatureAction)->asSequence()->at(1))
				{
					var tmp : WriteStructuralFeatureAction :=
						sfa->oclAsType(WriteStructuralFeatureAction)->asSequence()
						->at(1);
					outputPin := tmp._result;
				}
				else if (sfa->oclIsTypeOf(ClearStructuralFeatureAction)->asSequence()->at(1))
				{
					var tmp : ClearStructuralFeatureAction :=
						sfa->oclAsType(ClearStructuralFeatureAction)->asSequence()
						->at(1);
					outputPin := tmp._result;
				}
				else if (sfa->oclIsTypeOf(AddStructuralFeatureValueAction)->asSequence()->at(1))
				{
					var tmp : AddStructuralFeatureValueAction :=
						sfa->oclAsType(AddStructuralFeatureValueAction)->asSequence()
						->at(1);
					outputPin := tmp._result;
				}
				else if (sfa->oclIsTypeOf(RemoveStructuralFeatureValueAction)->asSequence()->at(1))
				{
					var tmp : RemoveStructuralFeatureValueAction :=
						sfa->oclAsType(RemoveStructuralFeatureValueAction)->asSequence()
						->at(1);
					outputPin := tmp._result;
				}
				else
				{
					inlog("WARNING #3: uncrecognized Structural feature action type");
				}; 
				
				var sfaResultTypeQualName : String := outputPin.type.qualifiedName;
				
				idx := sfaResultTypeQualName.indexOf(ALF_PKG_NAME);
				if (idx > 0)
				{
					inlog("Found StructuralFeatureAction result: " + sfaResultTypeQualName);
					
					var type : Type := resolveTypeUsingSet(resolverSet, outputPin.type);

					if (type <> null)
					{
						inlog("Updating result.type field of StructuralFeatureAction " + 
							sfa.name + " as " + type.name);
						
						if (sfa->oclIsTypeOf(ReadStructuralFeatureAction)->asSequence()->at(1))
						{
							var tmp : ReadStructuralFeatureAction :=
								sfa->oclAsType(ReadStructuralFeatureAction)->asSequence()
								->at(1);
							tmp._result.type := type;
						}
						else if (sfa->oclIsTypeOf(WriteStructuralFeatureAction)->asSequence()->at(1))
						{
							var tmp : WriteStructuralFeatureAction :=
								sfa->oclAsType(WriteStructuralFeatureAction)->asSequence()
								->at(1);
							tmp._result.type := type;
						}
						else if (sfa->oclIsTypeOf(ClearStructuralFeatureAction)->asSequence()->at(1))
						{
							var tmp : ClearStructuralFeatureAction :=
								sfa->oclAsType(ClearStructuralFeatureAction)->asSequence()
								->at(1);
							tmp._result.type := type;
						}
						else if (sfa->oclIsTypeOf(AddStructuralFeatureValueAction)->asSequence()->at(1))
						{
							var tmp : AddStructuralFeatureValueAction :=
								sfa->oclAsType(AddStructuralFeatureValueAction)->asSequence()
								->at(1);
							tmp._result.type := type;
						}
						else if (sfa->oclIsTypeOf(RemoveStructuralFeatureValueAction)->asSequence()->at(1))
						{
							var tmp : RemoveStructuralFeatureValueAction :=
								sfa->oclAsType(RemoveStructuralFeatureValueAction)->asSequence()
								->at(1);
							tmp._result.type := type;
						}
						else
						{
							inlog("WARNING #4: uncrecognized Structural feature action type");
						}; 
						
						count := count + 1;
					}
					else
					{
						inlog("WARNING #5: don't know what to do with unknown " + 
							"StructuralFeatureAction object.type: " + sfaObjectTypeQualName);
					};
				};
			};    
			
			sfa.input->forEach(inputPin) {
				
				if (inputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
				{
					var type : Type := resolveTypeUsingSet(resolverSet, inputPin.type);
					if (type <> null)
					{
						inlog("Updating inputPin.type field of StructuralFeatureAction " + 
							sfa.name + " as " + type.name);
						inputPin.type := type;
						count := count + 1;
					}
					else
					{
						inlog("WARNING #6: could not resolve type: " + inputPin.type.name);
					};
				};
			};
			
			sfa.output->forEach(outputPin) {
				
				if (outputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0) 
				{
					var type : Type := resolveTypeUsingSet(resolverSet, outputPin.type);
					if (type <> null)
					{
						inlog("Updating outputPin.type field of StructuralFeatureAction " + 
							sfa.name + " as " + type.name);
						outputPin.type := type;
						count := count + 1;
					}
					else
					{
						inlog("WARNING #7: could not resolve type: " + outputPin.type.name);
					};
				}	
			};
		}
		else if (e.oclIsKindOf(ReadSelfAction)) 
		{
			var rsa : ReadSelfAction := e.oclAsType(ReadSelfAction);
			var rsaResultTypeQualifiedName : String := rsa.result.type.qualifiedName;
			
			if (rsaResultTypeQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: ReadSelfAction result.type: " + rsaResultTypeQualifiedName);
				count := count + 1; 
				
				var rsaResultTypeName : String := rsa.result.type.name;
				
				if (rsaResultTypeName = e2Cls.name)
				{
					rsa.result.type := e2Cls;
					inlog("Updated result.type field of ReadSelfAction: " + rsa.name);
					count := count + 1;
				}
				else
				{
					inlog("WARNING #8: unrecognized type: " + rsaResultTypeName + 
						" in ReadSelfAction");
				};
			};
		}
		else if (e.oclIsKindOf(CallOperationAction))
		{
			var coa : CallOperationAction := e.oclAsType(CallOperationAction);
			var coaOpQualifiedName = coa.operation.qualifiedName;
			
			if (coaOpQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation operation: " + coaOpQualifiedName);
				
				var op := resolveOperationUsingSet(resolverSet, coa.operation);
				
				if (op <> null)
				{
					inlog("Updating operation field of CallOperationAction: " + coa.name);
					coa.operation := op;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #9: could not resolve Operation: " + coa.operation.name + 
						" in CallOperationAction");
				};
			};
			
			var coaTargetTypeQName : String := coa.target.type.qualifiedName;
			 
			if (coaTargetTypeQName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation target type: " + coaTargetTypeQName);
				
				var type : Type := resolveTypeUsingSet(resolverSet, coa.target.type);
				
				if (type <> null)
				{
					inlog("Updating target.type field of CallOperationAction: " + coa.name +
						" as " + type.name);
					coa.target.type := type;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #10: could not resolve type: " + coa.target.type.name);	
				};
			};
			
			coa.argument->forEach(arg)
			{
				var coaArgumentTypeQName : String := arg.type.qualifiedName;
				if (coaArgumentTypeQName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found: CallOperationAction argument type: " + coaArgumentTypeQName);
					
					var type : Type := resolveTypeUsingSet(resolverSet, arg.type);
					if (type <> null)
					{
						inlog("Updating argument.type field of CallOperationAction: " + coa.name + 
							" as " + type.name);
						arg.type := type;
						count:= count +1;
					}
					else
					{
						inlog("WARNING #11: could not resolve type: " + arg.type.name);	
					};
				};
			};
			
			coa._result->forEach(res)
			{
				var coaResultTypeQName := res.type.qualifiedName;
				if (coaResultTypeQName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found CallOperationAction result tyupe: " + coaResultTypeQName);
					
					var type := resolveTypeUsingSet(resolverSet, res.type);
					if (type <> null)
					{
						inlog("Updating result.type field of CallOperationAction: " + coa.name + 
							" as " + type.name);
						res.type := type;
						count := count + 1;
					};
				};
			};
		}
		else if (e.oclIsKindOf(ActivityParameterNode))
		{
			var activityParameterNode : ActivityParameterNode := 
				e.oclAsType(ActivityParameterNode);
			
			var apnTypeQualifiedName : String := activityParameterNode.type.qualifiedName;
			
			if (apnTypeQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: ActivityParameterNode type: " + apnTypeQualifiedName);
				
				var type : Type := resolveTypeUsingSet(resolverSet, activityParameterNode.type);
				if (type <> null)
				{
					inlog("Updating type field of ActivityParameterNode: " + 
						activityParameterNode.name + " as " + type.name);
					activityParameterNode.type := type;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #12: could not resolve type: " + activityParameterNode.type.name);
				};
			};
		}
		else if (e.oclIsKindOf(ExpansionRegion))
		{
			var er : ExpansionRegion := e.oclAsType(ExpansionRegion);
			
			er.structuredNodeInput->forEach(sni) {
				var qualName : String := sni.type.qualifiedName;
				
				if (qualName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found: ExpansionReqion structuredNodeInput type: " + qualName);
					
					var type : Type := resolveTypeUsingSet(resolverSet, sni.type);
					if (type <> null)
					{
						inlog("Updating type field of structured node input: " + sni.name + 
							" as " + type.name);
						sni.type := type;
						count := count + 1;					
					}
					else
					{
						inlog("WARNING #13: could not resolve type: " + sni.type.name);
					};
				};
			};
		}
		else if (e.oclIsKindOf(CreateObjectAction))
		{
			var coa : CreateObjectAction := e.oclAsType(CreateObjectAction);
			
			if (coa.classifier.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CreateObjectAction: classifier: " + coa.classifier.name);
				
				var cls : Class := resolveClassUsingSet(resolverSet, coa.classifier);
				
				if (cls <> null)
				{
					inlog("Updating classifier field of CreateObjectAction " + coa.name + " as " + 
						cls.name);
					coa.classifier := cls;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #14: could not resolve type: " + coa.classifier.name);
				};
			};
			
			if (coa._result.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CreateObjectAction: result type: " + coa._result.type.name);
				
				var type : Type := resolveTypeUsingSet(resolverSet, coa._result.type);
				
				if (type <> null)
				{
					inlog("Updating classifier field of CreateObjectAction " + coa.name + " as " + 
						type.name);
					coa._result.type := type;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #15: could not resolve type: " + coa._result.type.name);
				};
			};
		}
		else if (e.oclIsKindOf(StructuredActivityNode))
		{
			var san : StructuredActivityNode := e.oclAsType(StructuredActivityNode);
			
			san.structuredNodeInput->forEach(sni) {
				var qualName : String := sni.type.qualifiedName;
				
				if (qualName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found: StructuredActivityNode structuredNodeInput type: " + qualName);
					
					var type : Type := resolveTypeUsingSet(resolverSet, sni.type);
					if (type <> null)
					{
						inlog("Updating type field of structured node input: " + sni.name + 
							" as " + type.name);
						sni.type := type;
						count := count + 1;					
					}
					else
					{
						inlog("WARNING #18: could not resolve type: " + sni.type.name);
					};
				};
			};
			
			san.structuredNodeOutput->forEach(sno)
			{
				var qualName : String := sno.type.qualifiedName;
				
				if (qualName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found: StructuredActivityNode structuredNodeOutput type: " + qualName);
					
					var type : Type := resolveTypeUsingSet(resolverSet, sno.type);
					if (type <> null)
					{
						inlog("Updating type field of structured node output: " + sno.name + 
							" as " + type.name);
						sno.type := type;
						count := count + 1;					
					}
					else
					{
						inlog("WARNING #18: could not resolve type: " + sno.type.name);
					};
				};				
			};
			
			
			if (san.oclIsKindOf(LoopNode))
			{
				var loopNode : LoopNode := e.oclAsType(LoopNode);
				
				loopNode.loopVariable->forEach(lv)
				{
					if (lv.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
					{
						inlog("Found loop variable type: " + lv.name);
						
						var type : Type := resolveTypeUsingSet(resolverSet, lv.type);
						if (type <> null)
						{
							inlog("Updating type field of loop variable " + lv.name + " as " + 
								type.name);
							lv.type := type;
							count := count + 1;
						}
						else
						{
							inlog("WARNING #19: could not resolve type: " + lv.type.name);
						};
					};
				};
			};
		}
		else if (e.oclIsKindOf(Parameter))
		{
			var param : Parameter := e.oclAsType(Parameter);
			
			if (param.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found Parameter type: " + param.name);
				
				var type : Type := resolveTypeUsingSet(resolverSet, param.type);
				if (type <> null)
				{
					inlog("Updating type field of parameter: " + param.name);
					param.type := type;
					count := count + 1;
				}
				else
				{
					inlog("WARNING #17: could not resolve type: " + param.type.name);
				};
			};
		};
	};
	
	inlog("Replaced " + count.toString() + " references");
	endLog("Done");
}


// Find model element represented by the pathStr 
helper getModelElement(pathStr: String, inputModel:uml) : Element
{	
	var allObjects := inputModel.rootObjects().allSubobjects();
	
	allObjects->forEach(e) {
		if (e.oclIsKindOf(NamedElement)->asSequence()->at(1) = true)
		{
			var ne : NamedElement := e->oclAsType(NamedElement)->asSequence()->at(1);
			  
			var elementPath : String := getModelPath(ne);
			
			if (elementPath = pathStr)
			{
				return e->oclAsType(Element)->asSequence()->at(1);
			};	
		};
	};
	
	return null;
}
