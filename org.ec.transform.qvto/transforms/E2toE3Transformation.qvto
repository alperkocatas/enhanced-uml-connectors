import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');


// The plan is to take as input two uml models, and output another uml model 
transformation E2toE3Transformation(inout e2Model:uml, in fUmlModel:uml) 
	access EcTransformationLibrary;

configuration property CONNECTOR_CLS_MODEL_PATH : String;
configuration property OUTPORT_MULTIPLICITY : Integer;
configuration property ALF_PKG_NAME : String;

configuration property IFC_ASSOC_NAME : String;
configuration property LogIndentLevel : Integer;

helper checkConfigurationPropertyValues() {
			
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "OutPort";
		
	assert fatal (CONNECTOR_CLS_MODEL_PATH <> null) with 
		log("CONNECTOR_CLS_MODEL_PATH parameter is mandatory");
	
	assert fatal (OUTPORT_MULTIPLICITY <> null) with 
		log("OUTPORT_MULTIPLICITY parameter is mandatory");
				
	assert fatal (ALF_PKG_NAME <> null) with 
		log("ALF_PKG_NAME parameter is mandatory");
}


main() {
	initializeLogger();
	beginLog('Starting E2 to E3 transformation');

	// can we just write a huge helper function which will do all the manipulation? 
	transformE2toE3();
	
	endLog('Done');	
}

constructor Property::Property(nameArg:String, typeArg : Interface, 
							  lowerArg: Integer, upperArg: Integer) {
	name := nameArg;
	type := typeArg;
	lower := lowerArg;
	upper := upperArg;
}


// We are searching for an activity like name "xOp$method$1";
// and we want to skip names like destroy$method$1, ConnectorCls$method$1, 
// ConnectorCls$initialization$1... 
helper findConnectorBehaviorActivity(fUmlConCls: Class) : Activity {
														
	var behaviorSet : Set(Behavior) := fUmlConCls.ownedBehavior
		->select(name.indexOf(fUmlConCls.name +"$") <= 0 and 
				 name.indexOf("destroy" + "$") <= 0);
		
	assert fatal (behaviorSet->size() = 1) with 
		log("fUML class " + fUmlConCls.name + " has more than one activities for connector " + 
		    "behavior candidate!");	
		
	var fUmlConnectorBehaviorActivity : Activity := 
		behaviorSet->oclAsType(Activity)->asSequence()->at(1);
	
	return fUmlConnectorBehaviorActivity;
}


helper transformE2toE3()  {

	checkConfigurationPropertyValues();
	
	beginLog("Locating e2 model elements...");
	
	// now, let's locate the connector class inside the e2 model: 
	var e2ModelElt : Model := e2Model.rootObjects()[Model]->asSequence()->at(1);
	var allObjects : Set(Element) := e2Model.rootObjects()->oclAsType(Element)->asSet();
		
	var e2ConCls : Class := getModelElement(CONNECTOR_CLS_MODEL_PATH, e2Model)
		->oclAsType(Class)->asSequence()->at(1);
	assert fatal (e2ConCls <> null) with
		log("Could not find class " + CONNECTOR_CLS_MODEL_PATH + " in input model");
	
	//var e2ContainerCls : Class := e2ConCls.owner->oclAsType(Class)->asSequence()->at(1);
	var e2xIfc : Interface := getInterfaceFromConnectorCls(e2ConCls);
	//var e2xOp : Operation := e2xIfc.ownedOperation->asSequence()->at(1);
		
	endLog("Done");
	
	beginLog("Locating fUML model elements");
	
	// locate fUML model elements: ConnectorClass should be under the package named in alf 
	var fUmlModel : Model := fUmlModel.rootObjects()[Model]->asSequence()->at(1);
	
	var fUmlPkg : Package := fUmlModel.packagedElement
		->select(name = ALF_PKG_NAME)
		->oclAsType(Package)->asSequence()->at(1);
						      
	var fUmlConCls : Class := fUmlPkg.packagedElement
		->select(name = e2ConCls.name)->oclAsType(Class)->asSequence()->at(1);
														
	var fUmlConnectorBehaviorActivity : Activity := findConnectorBehaviorActivity(fUmlConCls);
	
	endLog("Done");

	var resolverSet : Set(Element);
	
	importClassBehaviorsFromFumlModel(e2ConCls, fUmlConCls, e2xIfc);
}

helper importClassBehaviorsFromFumlModel(inout e2Cls : Class, inout fumlClass: Class, 
	in e2xIfc: Interface)
{
	// Copy attributes of fUML class which does not exist in the e2 class:
	fumlClass.ownedAttribute->forEach(fUmlAttr)
	{
		if (e2Cls.ownedAttribute->select(name = fUmlAttr.name)->size() = 0)
		{
			e2Cls.ownedAttribute += fUmlAttr;
		}
	};
	
	// Transform operations under e2 class: 
	fumlClass.ownedOperation->forEach(fUmlOperation)
	{
		var opBehavior : Activity := fUmlOperation.method->oclAsType(Activity)->asSequence()->at(1);
		var theOperation : Operation := null;
		
		// Check if the operation exists in the e2 class: 
		if (e2Cls.ownedOperation->select(name = fUmlOperation.name)->size() <> 0)
		{
			var e2Op : Operation := 
				e2Cls.ownedOperation->select(name = fUmlOperation.name)
				->asSequence()->at(1);
			
			// Delete existing method of e2 operation;
			if (e2Op.method != null)
			{
				e2Model.removeElement(e2Op.method.oclAsType(Element)->asSequence()->at(1));
			};
			
			// Set specification of the newActivity to xOp in the e2 model. 
			opBehavior.specification := e2Op;
			theOperation := e2Op;
		}
		else
		{
			// move the operation into e2Cls
			e2Cls.ownedOperation += fUmlOperation;
			theOperation := fUmlOperation; 
		};
		
		// move operation behavior under e2class
		e2Cls.ownedBehavior += opBehavior;
		
		transformOperationBehavior(e2Cls, theOperation, opBehavior, e2xIfc);
	};
	
	// Do the same things for nested classes? 
	e2Cls.nestedClassifier->forEach(nestedE2Classifier)
	{
		var nesteE2Class : Class := nestedE2Classifier->oclAsType(Class)->asSequence()->at(1); 
		var fUmlNestedClass : Class := fumlClass.nestedClassifier->select(name = nesteE2Class.name)
			->oclAsType(Class)->asSequence()->at(1);
			
		assert fatal (fUmlNestedClass <> null) with log("No counterpart for the nested " + 
			"e2 model classifier " + nesteE2Class.name + " under fUML class " + fumlClass.name);
	
		importClassBehaviorsFromFumlModel(nesteE2Class, fUmlNestedClass, e2xIfc);
	};
}

// Copy given fUmlActivity into given e2Cls class, 
// e2xOp will be the specification of the new activity 
// and new activity will be the method of operation e2xOp. 
// e2Ifc will be replaced with its e2Ifc counterparts
// if found in fUmlActivity 
helper transformOperationBehavior(
	inout e2Cls: Class, 
	inout e2xOp : Operation,
	in fUmlActivity: Activity, 
	in e2Ifc : Interface)
{

	var count : Integer := 0;
	
	beginLog("Fixing unresolved operation parameters of " + e2xOp.name);
	
	e2xOp.ownedParameter->forEach(param) {
	
		var qualName : String := param.type.qualifiedName;
		
		if (qualName.indexOf(ALF_PKG_NAME) > 0)
		{
			inlog("Found parameter: " + param.name);
			if (param.name = e2Cls.name)
			{
				inlog("Updating type field of parameter " + param.name + " as " + e2Cls.name);
				param.type := e2Cls;
				count := count + 1;
			}
		}
	};
	
	endLog("Done");
	
	beginLog("Fixing unresolved references of connector behavior activity in e2 Model");
	
	var allStuff : Set(Element) := fUmlActivity[Activity]->allOwnedElements()
		->asSequence()->at(1);
	 
	allStuff->forEach(e) {
		
		if (e.oclIsKindOf(StructuralFeatureAction))
		{
			var sfa : StructuralFeatureAction = e.oclAsType(StructuralFeatureAction);
			
			var sfname : String := sfa.structuralFeature.name;
			var sfqualifiedName : String := sfa.structuralFeature.qualifiedName;
			
			var idx : Integer := sfqualifiedName.indexOf(ALF_PKG_NAME);  
			if (idx > 0)
			{
				inlog("Found: StructuralFeatureAction: " + sfqualifiedName);
				count := count + 1; 	
				
				// Now, we should do a name resolution here. 
				// Try to find the structuralFeature in the connectorClass. 
				var foundCount : Integer := e2Cls[Class].allAttributes()
					->collect(name = sfname)->count(true);
				
				if (foundCount != 1)
				{ 
					inlog("WARNING: Expected to find exactly 1 attribute with name " + sfname + 
						" under class " + e2Cls.qualifiedName  + " but found " + 
						foundCount.toString());
				}
				else
				{
					var e2Property : Property := e2Cls[Class].allAttributes()
						->select(name = sfname)->oclAsType(Property)->asSequence()->at(1);
												 	
					// Now, let's alter the structural feature to this one. 
					sfa.structuralFeature := e2Property;
					inlog("Updated structuralFeature field of StructuralFeatureAction " + 
						sfqualifiedName);
				}
			};    
			
			sfa.input->forEach(inputPin) {
				
				if (inputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
				{
					if (inputPin.type.name = e2Cls.name) 
					{
						inputPin.type := e2Cls;
						inlog("Updated inputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2Cls.name);
					}
				}
				else if (inputPin.type.name = e2Ifc.name)
				{
					inputPin.type := e2Ifc;
					inlog("Updated inputPin.type field of StructuralFeatureAction " + 
						sfqualifiedName + " as " + e2Ifc.name);	
				}
			};
			
			sfa.output->forEach(outputPin) {
				
				if (outputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0) 
				{
					if (outputPin.type.name = e2Cls.name)
					{
						outputPin.type := e2Cls;
						inlog("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2Cls.name);
					}
					else if (outputPin.type.name = e2Ifc.name)
					{
						outputPin.type := e2Ifc;
						inlog("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2Ifc.name);	
					}
				}	
			};
			
			
		}
		else if (e.oclIsKindOf(ReadSelfAction)) 
		{
			var rsa : ReadSelfAction := e.oclAsType(ReadSelfAction);
			var rsaResultTypeQualifiedName : String := rsa.result.type.qualifiedName;
			
			if (rsaResultTypeQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: ReadSelfAction result.type: " + rsaResultTypeQualifiedName);
				count := count + 1; 
				
				var rsaResultTypeName : String := rsa.result.type.name;
				
				// Now, should we be specific about it and assume that the type is 
				// of ConnectorCls? 
				// TODO: may require revising
				if (rsaResultTypeName = e2Cls.name)
				{
					rsa.result.type := e2Cls;
					inlog("Updated result.type field of ReadSelfAction: " + rsa.name);
				}
			}
		}
		else if (e.oclIsKindOf(CallOperationAction))
		{
			var coa : CallOperationAction := e.oclAsType(CallOperationAction);
			var coaOpQualifiedName = coa.operation.qualifiedName;
			
			if (coaOpQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation operation: " + coaOpQualifiedName);
				
				var coaOpName := coa.operation.name;
				
				if (coaOpName = e2xOp.name)
				{
					inlog("Updating operation field of CallOperationAction: " + coa.name);
					coa.operation := e2xOp;
					count := count + 1;
				}
				
			};
			
			var coaTargetTypeQName : String := coa.target.type.qualifiedName;
			 
			if (coaTargetTypeQName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation target type: " + coaTargetTypeQName);
				
				var coaTargetTypeName : String := coa.target.type.name;
				if (coaTargetTypeName = e2Cls.name)
				{
					inlog("Updating target.type field of CallOperationAction: " + coa.name +
						" as " + e2Ifc.name);
					coa.target.type := e2Cls;
					count := count + 1;
				}
				else if (coaTargetTypeName = e2Ifc.name)
				{
					inlog("Updating target.type field of CallOperationAction: " + coa.name + 
						" as " + e2Ifc.name);
					coa.target.type := e2Ifc;
					count := count + 1;
				}
			}
		}
		else if (e.oclIsKindOf(ActivityParameterNode))
		{
			var activityParameterNode : ActivityParameterNode := 
				e.oclAsType(ActivityParameterNode);
			
			var apnTypeQualifiedName : String := activityParameterNode.type.qualifiedName;
			
			if (apnTypeQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: ActivityParameterNode type: " + apnTypeQualifiedName);
				if (activityParameterNode.type.name = e2Cls.name)
				{
					inlog("Updating type field of ActivityParameterNode: " + 
						activityParameterNode.name + " as " + e2Cls.name);
					activityParameterNode.type := e2Cls;
					count := count + 1;
				}
				else
				{
					inlog("WARNING: don't know what to do with unknown ActivityParameterNode type");
				}
			}	
		}
		else if (e.oclIsKindOf(ExpansionRegion))
		{
			var er : ExpansionRegion := e.oclAsType(ExpansionRegion);
			
			er.structuredNodeInput->forEach(sni) {
				var qualName : String := sni.type.qualifiedName;
				
				if (qualName.indexOf(ALF_PKG_NAME) > 0)
				{
					inlog("Found: ExpansionReqion structuredNodeInput type: " + qualName);
					if (sni.type.name = e2Cls.name)
					{
						inlog("Updating type field of structured node input: " + sni.name + 
							" as " + e2Cls.name);
						sni.type := e2Cls;
						count := count + 1;
					}
				}
			}
		}
	};
	
	
	inlog("Replaced " + count.toString() + " references");
	endLog("Done");
}


// Find model element represented by the pathStr 
helper getModelElement(pathStr: String, inputModel:uml) : Element
{	
	var allObjects := inputModel.rootObjects().allSubobjects();
	
	allObjects->forEach(e) {
		if (e.oclIsKindOf(NamedElement)->asSequence()->at(1) = true)
		{
			var ne : NamedElement := e->oclAsType(NamedElement)->asSequence()->at(1);
			  
			var elementPath : String := getModelPath(ne);
			
			if (elementPath = pathStr)
			{
				return e->oclAsType(Element)->asSequence()->at(1);
			}	
		}
	};
	
	return null;
}
