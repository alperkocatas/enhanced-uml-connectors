import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation E2ToAlfTransformation(in e2Model:uml) access EcTransformationLibrary;

// properties that should be set from outside: 
configuration property CONNECTOR_CLS_MODEL_PATH : String;
configuration property OUTPORT_MULTIPLICITY : Integer;

configuration property IFC_ASSOC_NAME : String;
configuration property ALF_PKG_NAME : String;

configuration property alfCode : String;
configuration property AlfIndentLevel : Integer;

helper checkConfigurationPropertyValues() {
	
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "OutPort";
		
	AlfIndentLevel := 0;	
	
	assert fatal (ALF_PKG_NAME <> null) with 
		log("ALF_PKG_NAME parameter is mandatory");
	
	assert fatal (CONNECTOR_CLS_MODEL_PATH <> null) with 
		log("CONNECTOR_CLS_MODEL_PATH parameter is mandatory");
	
	assert fatal (OUTPORT_MULTIPLICITY <> null) with 
		log("OUTPORT_MULTIPLICITY parameter is mandatory");
}

main() {
	initializeLogger();
	beginLog("Starting E2 to Alf Transformation...");
	
	// can we just write a huge helper function which will do all the manipulation? 
	generateAlfCodeFromE2Model();
	
	endLog("Done");
}

helper generateAlfCodeFromE2Model() {
	checkConfigurationPropertyValues();

	var arg : String := e2Model.rootObjects()[Model].name->asSequence()->at(1);
	
	var e2ConCls : Class := getModelElement(CONNECTOR_CLS_MODEL_PATH, e2Model)
		->oclAsType(Class)->asSequence()->at(1);
		
	assert fatal (e2ConCls <> null) with
		log("Could not find class " + CONNECTOR_CLS_MODEL_PATH + " in input model");
		
	var e2ContainerCls : Class := e2ConCls.owner->oclAsType(Class)->asSequence()->at(1); 
	
	var e2xIfc : Interface := getInterfaceFromConnectorCls(e2ConCls);
	
	var xOpName : String := e2xIfc.ownedOperation->asSequence()->at(1).name;
	
	var e2xOp : Operation := e2ConCls.ownedOperation->select(name = xOpName)
		->oclAsType(Operation)->asSequence()->at(1);
	
	assert fatal (e2xOp.method != null and 
		e2xOp.method.oclIsKindOf(Activity)->asSequence()->at(1)) 
		with log("Operation " + e2xOp.name + " has no connector behavior attached"); 
	
	var connectorBehavior : Activity := e2xOp.method->oclAsType(Activity)->asSequence()->at(1);
	
	alfCode := "";
	generateAlfCodeImports();
	beginAlfPackage(ALF_PKG_NAME);
	generateInterfaceCode(e2xIfc);	
	beginConnectorClass(e2ConCls, e2xIfc);
	generateConnectorClassAttributes(e2ConCls, e2xIfc);	
	generateConnectorBehaviorOperation(e2xOp, connectorBehavior);	
	endConnectorClass();	
	endAlfPackage();
	
	inlog("<begin> Alf Code: ");
	log(alfCode);
	inlog("<end> Alf Code");
}

helper generateConnectorBehaviorOperation(e2xOp: Operation, connectorBehavior: Activity) {
		
	var operationSignatureStr : String := "public " + e2xOp.name + "("; 
	
	var count : Integer := 0;
	
	var params : OrderedSet(Parameter) := e2xOp->ownedParameter->asSequence()->at(1);
	var paramCount : Integer := params->select(name != "returnVal")
		->asSequence()->size();
				
	e2xOp->ownedParameter->forEach(param) {
	
		var paramName : String := param.name->asSequence()->at(1);
	
		if (param.direction->asSequence()->at(1) <> ParameterDirectionKind::_return)
		{
			var paramStr : String := "";
			var paramTypeStr : String := param.type.name->asSequence()->at(1).toString();
			
			var paramDirectionStr = "in";
			if (param.direction->asSequence()->at(1) = ParameterDirectionKind::_out) {
				paramDirectionStr := "out";
			}
			else if (param.direction->asSequence()->at(1) = ParameterDirectionKind::_inout) {
				paramDirectionStr := "inout";
			};
			
			paramStr := paramStr + paramDirectionStr + " " + paramName + ": " + paramTypeStr;
			count := count + 1;
			
			if (count < paramCount)
				paramStr := paramStr + ", ";
			
			operationSignatureStr := operationSignatureStr + paramStr;
		}
	};
	
	operationSignatureStr := operationSignatureStr + ")";
	
	if (params->select(name = "returnVal")->asSequence()->size() <> 0)
	{
		var returnParam : Parameter = params->select(name = "returnVal")->asSequence()->at(1);
		
		operationSignatureStr := operationSignatureStr + " : " + returnParam.type.name.toString(); 	
	};
	
	operationSignatureStr := operationSignatureStr + " {";
	
	appendAlfCodeLine(operationSignatureStr);
	AlfIndentLevel := AlfIndentLevel + 1;
	
	// TODO: Transform request(args, Index) definition to
	// ItsIfcPtr[Index]->xOp(args)
	// or.. just use the actual notation there. 
	// For now, lets just use a common notation:
	// OutPort->xOp(request...)
	var opaqueAction := connectorBehavior.ownedElement
		->selectByKind(OpaqueAction)->asSequence()->at(1);
	
	// TODO: get the real OUTPORT_MULTIPLICITY value as a parameter 
	// from the E1 to E2 transformation. 
	var opaqueActionBody : String := opaqueAction.body->asSequence()->at(1);
	var transformedOpaqueActionBody : String:= opaqueActionBody
		->replaceAll("PRV_CNT", OUTPORT_MULTIPLICITY.toString())
		->asSequence()->at(1);
		
	
	appendAlfCodeLine(transformedOpaqueActionBody);
	
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");  
	
}

helper generateConnectorClassAttributes(e2ConCls: Class, e2xIfc : Interface) {
	
	// Create the interface array
	var interfacePtrArrayStr : String := "public " + IFC_ASSOC_NAME + " : " + e2xIfc.name + 
		"[" + OUTPORT_MULTIPLICITY.toString() + "] ordered nonunique;";
	
	appendAlfCodeLine(interfacePtrArrayStr);
	
	e2ConCls.ownedAttribute->forEach(attr) {
		
		if (attr.type != null)
		{
			if (attr->oclIsKindOf(Port)->asSequence()->at(1) = false)
			{
				var attrCode : String := "private ";
				var attrName : String := attr.name;
				
				if (attr.type.name = null)
				{
					inlog("WARNING: type name of attribute " + attrName + " seems to be null");
				};
				
				var attrType : String := attr.type.name.toString();
				attrCode := attrCode + attrName + " : " + attrType;
				
				if (attr.defaultValue != null)
				{
					if (attr.defaultValue->oclIsKindOf(LiteralInteger)->asSequence()->at(1))
					{
						var defVal : LiteralInteger :=
							attr.defaultValue->oclAsType(LiteralInteger)->asSequence()->at(1);  
					
						attrCode := attrCode + " = " + 
							defVal.value.toString();
					}
					else if (attr.defaultValue->oclIsKindOf(LiteralString)->asSequence()->at(1))
					{
						var defVal : LiteralString :=
							attr.defaultValue->oclAsType(LiteralString)->asSequence()->at(1);  
					
						attrCode := attrCode + " = " + 
							defVal.value.toString();
					}
					else
					{
						inlog("WARNING: Default value of attribute " + attrName + " is unrecognized");
					} 
				};
				
				attrCode := attrCode + ";";
								
				appendAlfCodeLine(attrCode);
			}
		}
		else
		{
			inlog("WARNING: Type of attribute " + attr.name + " is null")
		}
	}; //end: forEach
	
	appendAlfCodeLine(" ");
} 

helper beginConnectorClass(e2ConCls: Class, e2xIfc: Interface)
{
	appendAlfCodeLine(
		 "public class " + e2ConCls.name + 
		" specializes " + e2xIfc.name + " {");
		
	AlfIndentLevel := AlfIndentLevel + 1;	
}

helper endConnectorClass()
{
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");
}

helper generateInterfaceCode(ifc : Interface)
{
	// Generate interface alf code, which is like the following: 
	//  public abstract class XIfc
	//  {
	//     public abstract xOp(in arg: Integer): Integer;     
	//  }

	appendAlfCodeLine("public abstract class " + ifc.name);
	appendAlfCodeLine("{");
	AlfIndentLevel := AlfIndentLevel + 1;

	// For simplicity we assume that the interface has only one operation
	assert fatal (ifc.ownedOperation->size() = 1) 
		with log("Interface " + ifc.name + " must have exactly one operation ");

	var op : Operation = ifc.ownedOperation->asSequence()->at(1);

	// Now, we should iterate through parameters, and extract the single parameter, 
	// and the return parameter. 
	
	var inParamSet : Set(Parameter) := 
		op->ownedParameter->asSequence()->at(1)->select(direction = ParameterDirectionKind::_in);
	assert fatal(inParamSet->size() = 1) with log("Number of parameters with direction=in " +
		"must be 1 for operation " + op.name);
	var param : Parameter := inParamSet->asSequence()->at(1);
	
	var returnParamSet : Set(Parameter) := 
		op->ownedParameter->asSequence()->at(1)->select(direction = ParameterDirectionKind::_return);
	assert fatal(returnParamSet->size() = 1) with log("Number of parameters with direction=return " +
		"must be 1 for operation " + op.name);
	var returnParam : Parameter := returnParamSet->asSequence()->at(1); 
	
	// TODO: the hardcoded "in" parameter direction should be read from the source model
	
	appendAlfCodeLine("public abstract " + op.name + "(in " + param.name + ": " + 
		param.type.name.toString() + ") : " + returnParam.type.name.toString() + ";");
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}"); 
	appendAlfCodeLine(""); 
}

helper generateAlfCodeImports()
{
	appendAlfCodeLine( 
		"private import Alf::Library::PrimitiveBehaviors::IntegerFunctions::ToString;");
	appendAlfCodeLine(  
		"private import Alf::Library::PrimitiveBehaviors::IntegerFunctions::*;");
	appendAlfCodeLine("");
}

helper beginAlfPackage(packageName : String)
{
	appendAlfCodeLine("package " + packageName + " {");
	AlfIndentLevel := AlfIndentLevel + 1;
}

helper endAlfPackage()
{
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");
}

helper appendAlfCodeLine(line : String)
{
	//log(">>>>appending line: " + line);
	alfCode := alfCode + getAlfIndent() + line + "\n";
}

helper getAlfIndent() : String {
	var indentStr : String := '';
	var i : Integer := 0;
	
	while (i < AlfIndentLevel * 4) {
		indentStr := indentStr + ' ';
		i := i + 1;
	};
	
	return indentStr;
}


// Find model element represented by the pathStr 
helper getModelElement(pathStr: String, inputModel:uml) : Element
{	
	var allObjects := inputModel.rootObjects().allSubobjects();
	
	allObjects->forEach(e) {
		if (e.oclIsKindOf(NamedElement)->asSequence()->at(1) = true)
		{
			var ne : NamedElement := e->oclAsType(NamedElement)->asSequence()->at(1);
			  
			var elementPath : String := getModelPath(ne);
			
			if (elementPath = pathStr)
			{
				return e->oclAsType(Element)->asSequence()->at(1);
			}	
		}
	};
	
	return null;
}