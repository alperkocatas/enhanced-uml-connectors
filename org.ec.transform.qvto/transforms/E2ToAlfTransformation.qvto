// Defines the transformation rules for generating Alf code from E2 model. Generated Alf code
// includes enough information to generate fUML activities which precisely define the coordination
// behavior for the enhanced connector. 
 
// This transformation is defined as an in-place transformation. When it is ran from inside Eclipse,
// it will modify the input model. However, we normally run this using the EcTransformer, which is 
// a java application. EcTransformer uses the java API of QVTo to run the transformation, and after
// the transformation is complete, it saves the in-memory representation of the model into a 
// different UML file. 
// By defining the transformation as an in-place transformation but using Java API to save results
// into a different UML file, we can get a functionality which is equivalent to the "refining mode"
// of ATL transformation language. This functionality is useful when the transformation wants to 
// change a part of the input model, but leave the rest of the input model as unchanged.

// This transformation requires some input configuration properties, which should be set before
// running the transformation. This information is normally provided by the previous transformation
// in the transformation chain, which is the transformation from the E1 model into the E2 model. 

import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation E2ToAlfTransformation(in e2Model:uml) access EcTransformationLibrary;

// Configuration Properties that should be set from outside: 

// The path of the connector class generated for the enhanced connector 
configuration property CONNECTOR_CLS_MODEL_PATH : String;

// The number of providers connected to the enhanced connector
configuration property OUTPORT_MULTIPLICITY : Integer;

// The name of the association end generated for calling operations from the providers
configuration property IFC_ASSOC_NAME : String;

// The name of the Alf unit which will be generated for the enhanced connector
configuration property ALF_PKG_NAME : String;


// Internal configuration properties used as global variables: 
configuration property alfCode : String;
configuration property AlfIndentLevel : Integer;

// Checks if required configuration properties are provided correctly to the transformation: 
helper checkConfigurationPropertyValues() {
	
	// If not provided, use the name "OutPort"
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "OutPort";
		
	AlfIndentLevel := 0;	
	
	assert fatal (ALF_PKG_NAME <> null) with 
		log("ALF_PKG_NAME parameter is mandatory");
	
	assert fatal (CONNECTOR_CLS_MODEL_PATH <> null) with 
		log("CONNECTOR_CLS_MODEL_PATH parameter is mandatory");
	
	assert fatal (OUTPORT_MULTIPLICITY <> null) with 
		log("OUTPORT_MULTIPLICITY parameter is mandatory");
	
	assert fatal (IFC_ASSOC_NAME <> null) with 
		log("IFC_ASSOC_NAME parameter is mandatory");
		
}


main() {
	initializeLogger();
	beginLog("Starting E2 to Alf Transformation...");
	 
	generateAlfCodeFromE2Model();
	
	endLog("Done");
}


// Main helper function which generates Alf code
helper generateAlfCodeFromE2Model() {
	checkConfigurationPropertyValues();

	var arg : String := e2Model.rootObjects()[Model].name->asSequence()->at(1);
	
	var e2ConCls : Class := getModelElement(CONNECTOR_CLS_MODEL_PATH, e2Model)
		->oclAsType(Class)->asSequence()->at(1);
		
	assert fatal (e2ConCls <> null) with
		log("Could not find class " + CONNECTOR_CLS_MODEL_PATH + " in input model");
		
	var e2ContainerCls : Class := e2ConCls.owner->oclAsType(Class)->asSequence()->at(1); 
	
	var e2xIfc : Interface := getInterfaceFromConnectorCls(e2ConCls);
	
	var xOpName : String := e2xIfc.ownedOperation->asSequence()->at(1).name;
	
	var e2xOp : Operation := e2ConCls.ownedOperation->select(name = xOpName)
		->oclAsType(Operation)->asSequence()->at(1);
	
	assert fatal (e2xOp.method != null and 
		e2xOp.method.oclIsKindOf(OpaqueBehavior)->asSequence()->at(1)) 
		with log("Operation " + e2xOp.name + " has no connector behavior attached"); 
	
	var connectorBehavior : Activity := e2xOp.method->oclAsType(Activity)->asSequence()->at(1);
	
	alfCode := "";
	generateAlfCodeImports();
	beginAlfPackage(ALF_PKG_NAME);
	generateInterfaceCode(e2xIfc);	
	generateClassCode(e2ConCls);
	endAlfPackage();
	
	inlog("<begin> Alf Code: ");
	log(alfCode);
	inlog("<end> Alf Code");
}


helper generateConnectorBehaviorOperation(e2xOp: Operation, connectorBehavior: Activity) {
		
	var operationSignatureStr : String := "public " + e2xOp.name + "("; 
	
	var count : Integer := 0;
	
	var params : OrderedSet(Parameter) := e2xOp->ownedParameter->asSequence()->at(1);
	var paramCount : Integer := params->select(name != "returnVal")
		->asSequence()->size();
				
	e2xOp->ownedParameter->forEach(param) {
	
		var paramName : String := param.name->asSequence()->at(1);
	
		if (param.direction->asSequence()->at(1) <> ParameterDirectionKind::_return)
		{
			var paramStr : String := "";
			var paramTypeStr : String := param.type.name->asSequence()->at(1).toString();
			
			var paramDirectionStr = "in";
			if (param.direction->asSequence()->at(1) = ParameterDirectionKind::_out) {
				paramDirectionStr := "out";
			}
			else if (param.direction->asSequence()->at(1) = ParameterDirectionKind::_inout) {
				paramDirectionStr := "inout";
			};
			
			paramStr := paramStr + paramDirectionStr + " " + paramName + ": " + paramTypeStr;
			count := count + 1;
			
			if (count < paramCount)
				paramStr := paramStr + ", ";
			
			operationSignatureStr := operationSignatureStr + paramStr;
		}
	};
	
	operationSignatureStr := operationSignatureStr + ")";
	
	if (params->select(name = "returnVal")->asSequence()->size() <> 0)
	{
		var returnParam : Parameter = params->select(name = "returnVal")->asSequence()->at(1);
		
		operationSignatureStr := operationSignatureStr + " : " + returnParam.type.name.toString(); 	
	};
	
	operationSignatureStr := operationSignatureStr + " {";
	
	appendAlfCodeLine(operationSignatureStr);
	AlfIndentLevel := AlfIndentLevel + 1;
	
	// We can transform request(args, Index) definition to
	// ItsIfcPtr[Index]->xOp(args)
	// or, we can just use the actual notation there. 
	// For now, lets just use a common notation:
	// OutPort->xOp(request...)
	var opaqueAction := connectorBehavior.ownedElement
		->selectByKind(OpaqueAction)->asSequence()->at(1);
	
	appendAlfCodeLine(opaqueAction.body->asSequence()->at(1));
	
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");  
	
}


helper generateClassAttributes(cls: Class)
{
	cls.ownedAttribute->forEach(attr) {
		
		if (attr.type != null)
		{
			if (attr->oclIsKindOf(Port)->asSequence()->at(1) = false)
			{
				var attrCode : String := "";
				
				if (attr.visibility = VisibilityKind::_private)
				{
					attrCode := attrCode + "private ";
				}
				else if (attr.visibility = VisibilityKind::_protected)
				{
					attrCode := attrCode + "protected ";
				}
				else if (attr.visibility = VisibilityKind::_public)
				{
					attrCode := attrCode + "public ";
				};
				
				var attrName : String := attr.name;
				
				if (attr.type.name = null)
				{
					inlog("WARNING: type name of attribute " + attrName + " seems to be null");
				};
				
				var attrType : String := attr.type.name.toString();		
				
				// Set the attribute type to Queue<attrType> if this is a request or reply buffer
				if (attr.hasStereotype("RequestBuffer"))
				{
					var st : Stereotype := attr.getAppliedStereotypes()->
						select(name = "RequestBuffer")
						->asSequence()->at(1);
		
					var bufferTypeLiteral : EnumerationLiteral := attr.getValue(st, "type")
						.oclAsType(EnumerationLiteral);
					
					if (bufferTypeLiteral.name = "Fifo")
						attrType := "Queue<" + attrType + ">";
				}
				else if (attr.hasStereotype("ReplyBuffer"))
				{
					var st : Stereotype := attr.getAppliedStereotypes()->
						select(name = "ReplyBuffer")
						->asSequence()->at(1);
		
					var bufferTypeLiteral : EnumerationLiteral := attr.getValue(st, "type")
						.oclAsType(EnumerationLiteral);
					
					if (bufferTypeLiteral.name = "Fifo")
						attrType := "Queue<" + attrType + ">";
				};
				
				attrCode := attrCode + attrName + " : " + attrType;
				
				var multiplicityStr : String := "[" + attr.lower.toString() + ".." +
													  attr.upper.toString() + "]";
								
				attrCode := attrCode + multiplicityStr;
				
				if (attr.isOrdered = true)
				{
					attrCode := attrCode + " ordered";
				};
				
				if (attr.isUnique = false)
				{
					attrCode := attrCode + " nonunique";
				};
				
				if (attr.defaultValue != null)
				{
					attrCode := attrCode + " = " + 
							attr._default.toString();
				};
				
				attrCode := attrCode + ";";
								
				appendAlfCodeLine(attrCode);
			}
		}
		else
		{
			inlog("WARNING: Type of attribute " + attr.name + " is null")
		}
	}; //end: forEach	
}


helper endConnectorClass()
{
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");
}


helper generateInterfaceCode(ifc : Interface)
{
	// Generate interface alf code, which is like the following: 
	//  public abstract class XIfc
	//  {
	//     public abstract xOp(in arg: Integer): Integer;     
	//  }

	appendAlfCodeLine("public abstract class " + ifc.name);
	appendAlfCodeLine("{");
	AlfIndentLevel := AlfIndentLevel + 1;
	appendAlfCodeLine( getInterfaceOperationSignature(ifc) + ";");
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}"); 
	appendAlfCodeLine(""); 
}

helper getInterfaceOperationSignature(ifc: Interface) : String
{
	// For simplicity we assume that the interface has only one operation
	assert fatal (ifc.ownedOperation->size() = 1) 
		with log("Interface " + ifc.name + " must have exactly one operation ");

	var op : Operation = ifc.ownedOperation->asSequence()->at(1);

	// Now, we should iterate through parameters, and extract the single parameter, 
	// and the return parameter. 
	
	var inParamSet : Set(Parameter) := 
		op->ownedParameter->asSequence()->at(1)->select(direction = ParameterDirectionKind::_in);
	
	assert fatal(inParamSet->size() = 1) with log("Number of parameters with direction=in " +
		"must be 1 for operation " + op.name);

	
	var returnParamSet : Set(Parameter) := 
		op->ownedParameter->asSequence()->at(1)->select(direction = ParameterDirectionKind::_return);
	assert fatal(returnParamSet->size() = 1) with log("Number of parameters with direction=return " +
		"must be 1 for operation " + op.name);

	var operationSignature := getOperationSignature(op, true);

	return operationSignature;
}


helper getOperationSignature(operation: Operation, generateAsAbstract: Boolean) : String
{
	// Now, we should iterate through parameters, and extract the single parameter, 
	// and the return parameter. 
	
	var parametersStr : String := "";
	operation->ownedParameter->forEach(param)
	{
		var p : Parameter := param->asSequence()->at(1);
	
		if (p.direction <> ParameterDirectionKind::_return)
		{
			parametersStr := parametersStr + "," + p.direction.toString() + " " + p.name + ":" + 
				p.type.name;
		}
	};
	
	parametersStr := parametersStr.replaceFirst(",", "");
	
	var returnParam : Parameter := 
		operation->ownedParameter->asSequence()->at(1)
		->select(direction = ParameterDirectionKind::_return)->asSequence()->at(1);
	
	var returnParamStr := "";
	if (returnParam <> null)
	{
		returnParamStr := ": " + returnParam.type.name;	
	};
	
	var abstractStr : String := "";
	if (generateAsAbstract = true)
		abstractStr := "abstract ";
	
	var signatureStr : String = 	
		operation.visibility.toString() + " " + abstractStr + operation.name + 
		"(" + parametersStr + ") " + returnParamStr;
	
	return signatureStr;
}


helper getOperationCode(operation: Operation, method: OpaqueBehavior) : String
{
	var operationCode : String := "";
	var signatureStr : String := getOperationSignature(operation, operation.isAbstract);
	operationCode := operationCode + signatureStr + "\n" + getAlfIndent() + "{\n";
	
	
	var operationBody : String := method.body->asSequence()->at(1);
	
	var lines : Sequence(String) := operationBody.tokenize("\n", true);
	operationBody := "";
	
	AlfIndentLevel := AlfIndentLevel + 1;
	lines->forEach(line)
	{
		operationBody := operationBody + getAlfIndent() + line; 
	};
	AlfIndentLevel := AlfIndentLevel - 1;
	
	operationCode := operationCode + operationBody;
	operationCode := operationCode + "\n" + getAlfIndent() + "}\n";
	return operationCode;
}


helper generateClassCode(cls:Class)
{
	var classDeclarationStr := "public class " + cls.name;
	
	if (cls.generalization->size() <> 0)
	{
		var specializationStr : String := classDeclarationStr + " specializes";
		
		cls.generalization->forEach(g)
		{
			if (g.oclIsKindOf(Class)->asSequence()->at(1) = true or
				g.oclIsKindOf(Interface)->asSequence()->at(1) = true)
			{
				var ne : NamedElement := g.oclAsType(NamedElement)->asSequence()->at(1);
				specializationStr := ", " + specializationStr + ne.name;
			}
		};
		
		specializationStr.replaceFirst(",", "");
		
		if (specializationStr <> " specializes")
		{
			classDeclarationStr := classDeclarationStr + specializationStr;
		}
	};
	
	appendAlfCodeLine(classDeclarationStr);
	
	appendAlfCodeLine("{");
	AlfIndentLevel := AlfIndentLevel + 1;
	
	generateClassAttributes(cls);
	appendAlfCodeLine("");

	// Generate operations which has methods as OpaqueBehaviors: 	
	cls->ownedOperation->forEach(operationSet)
	{ 
		operationSet->forEach(operation)
		{
			var operationBehavior : OpaqueBehavior := null;
			var behavior := operation.method->asSequence()->at(1);
			if (behavior->oclIsTypeOf(OpaqueBehavior)->asSequence()->at(1) = true)
			{
				operationBehavior := behavior->oclAsType(OpaqueBehavior)->asSequence()->at(1);
			};	
		
			if (operationBehavior <> null)
			{
				if (operation.name->asSequence()->at(1) = cls.name)
					appendAlfCodeLine("@Create");
				
				var operationCode : String := 
					getOperationCode(operation->asSequence()->at(1), operationBehavior);
					
				appendAlfCodeLine(operationCode);
			};
		};
	};
	
	// Generate nested classes
	cls.nestedClassifier->forEach(nestedCls)
	{
		if (nestedCls->oclIsTypeOf(Class)->asSequence()->at(1) = true)
		generateClassCode(nestedCls->oclAsType(Class)->asSequence()->at(1));	
	};
	
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}"); 
	appendAlfCodeLine("");
}


helper generateAlfCodeImports()
{
	appendAlfCodeLine( 
		"private import Alf::Library::PrimitiveBehaviors::IntegerFunctions::ToString;");
	appendAlfCodeLine(  
		"private import Alf::Library::PrimitiveBehaviors::IntegerFunctions::*;");
	appendAlfCodeLine("");
}


helper beginAlfPackage(packageName : String)
{
	appendAlfCodeLine("package " + packageName + " {");
	AlfIndentLevel := AlfIndentLevel + 1;
}


helper endAlfPackage()
{
	AlfIndentLevel := AlfIndentLevel - 1;
	appendAlfCodeLine("}");
}


helper appendAlfCodeLine(line : String)
{
	alfCode := alfCode + getAlfIndent() + line + "\n";
}


helper getAlfIndent() : String {
	var indentStr : String := '';
	var i : Integer := 0;
	
	while (i < AlfIndentLevel * 4) {
		indentStr := indentStr + ' ';
		i := i + 1;
	};
	
	return indentStr;
}


// Find model element represented by the pathStr 
helper getModelElement(pathStr: String, inputModel:uml) : Element
{	
	var allObjects := inputModel.rootObjects().allSubobjects();
	
	allObjects->forEach(e) {
		if (e.oclIsKindOf(NamedElement)->asSequence()->at(1) = true)
		{
			var ne : NamedElement := e->oclAsType(NamedElement)->asSequence()->at(1);
			  
			var elementPath : String := getModelPath(ne);
			
			if (elementPath = pathStr)
			{
				return e->oclAsType(Element)->asSequence()->at(1);
			}	
		}
	};
	
	return null;
}