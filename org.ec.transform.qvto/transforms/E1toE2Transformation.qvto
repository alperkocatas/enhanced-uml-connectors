// Defines the transformation rules from E1 model into E2 model. 
// This transformation is defined as an in-place transformation. When it is ran from inside Eclipse,
// it will modify the input model. However, we normally run this using the EcTransformer, which is 
// a java application. EcTransformer uses the java API of QVTo to run the transformation, and after
// the transformation is complete, it saves the in-memory representation of the model into a 
// different UML file. 
// By defining the transformation as an in-place transformation but using Java API to save results
// into a different UML file, we can get a functionality which is equivalent to the "refining mode"
// of ATL transformation language. This functionality is useful when the transformation wants to 
// change a part of the input model, but leave the rest of the input model as unchanged.   

// As this is a proof of concept implementation for the Enhanced Connector concept, the 
// transformations make the following specific assumptions to simplify implementation:  
// 1 - Although there is no design limitation for the transformation to handle multiple 
//     enhanced connectors in the input model, we assume that there will be at most one enhanced
//     connector in the model. Therefore, if we find one, we transform it and we stop the process. 
// 2 - We assume that the ports which are connected by the enhanced connectors provide or require
//     a single interface. Normall, UML ports can provide/require multiple interfaces at the same 
//     time. In that case, separate connector behaviors can be defined for coordinating each interface. 
// 3 - We assume that the interfaces required/provided by the ports declare a single operation, 
//     which has a return type and which has a single argument.
// 4 - We assume that the primary enhanced connectors and secondary enhanced connectors grouped by
//     dependencies form a connected group in the input E1 model, and therefore, we don't check 
//     against this requirement.    

import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation E1toE2Transformation(inout e1Model:uml)
	access EcTransformationLibrary;


main() {
	initializeLogger();
	beginLog("Starting E1 to E2 Transformation...");	
	transformE1toE2();
	endLog("Done");
}


// Main helper function which transforms the E1 model into E2 model
helper transformE1toE2()
{
	var model : Model := e1Model.rootObjects()[Model]->asSequence()->at(1);
	
	// Search for enhanced connectors inside the model 
	var allStuff : Set(Element) := model->allOwnedElements()
		->asSequence()->at(1);
	
	var foundOne : Boolean := false;
	
	allStuff->forEach(e) {
		
		if (e->oclIsKindOf(Connector)->asSequence()->at(1) = true)
		{
			var con : Connector = e->oclAsType(Connector)->asSequence()->at(1); 
			
			if (con.isPrimaryEnhancedConnector() )
			{
				inlog("Found a primary enhanced connector: " + con.name);
				
				var conf : String = con.getEcConfiguration();
				
				if (conf <> "UnknownConfiguration")
				{
					inlog("EC_CONFIGURATION=" + conf);
					foundOne := true;
					transformEcConnector(con, conf);
				}
				else
				{
					inlog("Error.. uncrecognized connector configuration: " + conf);
				};
				
				// For simplicity, let's assume that the model contains at most one 
				// enhanced connector. So, break after transforming it. 
				break;
			};
		};		
	};
	
	assert fatal (foundOne = true) with log("Could not find any enhanced connector in input model!"); 
}


// Analyze the enhanced connector and decide if it is a single requester, multiple provider 
// configuration. Returns one of the following: 
//	"SingleRequesterMultipleProvider",
//	"MultipleRequesterSingleProvider", 
//	"SingleRequesterSingleProvider" 
//  "UnknownConfiguration"
// 
query Connector::getEcConfiguration() : String {

	var requesterPorts : Set(Port);
	var providerPorts : Set(Port);

	var ports : List(Port) := self.GetProvidingAndRequiringEndPorts();
	var requiringPort: Port := ports->at(1);
	var providingPort: Port := ports->at(2);
	
	requesterPorts += requiringPort;
	providerPorts += providingPort;
	
	if (self.clientDependency->size() <> 0)
	{
		self.clientDependency->forEach(e) 
		{			
			var target : Element = e.target->asSequence()->at(1);
			
			if (target->oclIsKindOf(Connector)->asSequence()->at(1))
			{
				var secondaryEnhancedConnector : Connector = e.target.oclAsType(Connector)
					->asSequence()->at(1);
				
				ports := secondaryEnhancedConnector.GetProvidingAndRequiringEndPorts();
				var requiringPortSecondary : Port := ports->at(1);
				var providingPortSecondary : Port := ports->at(2);
				
				requesterPorts += requiringPortSecondary;
				providerPorts += providingPortSecondary;
			};
		};
	};
	
	if (requesterPorts->size() = 1 and providerPorts->size() > 1)
	{
		return "SingleRequesterMultipleProvider";
	}		
	else if (requesterPorts->size() > 1 and providerPorts->size() = 1 or 
		     requesterPorts->size() = 1 and providerPorts->size() = 1)
	{
		return "MultipleRequesterSingleProvider";
	};
	
	return "UnknownConfiguration";
}


// Performs the transformation steps for the given enhanced connector ec, 
// which has the given configuration conf. 
helper transformEcConnector(ec : Connector, conf : String)
{
	beginLog(">> begin: Processing " + ec.name + " as Primary Enhanced Connector..");
	inlogDebug("Connector configuration is: " + conf);
	
	var ownerClass : Class := ec.owner->oclAsType(Class)->asSequence()->at(1);
	
	var connectorCls : Class := new Class(ec.name + "_ConnectorCls");
	
	ownerClass.nestedClassifier += connectorCls;
	
	var connectorClsModelPath : String := getModelPath(connectorCls);
	inlog("CONNECTOR_CLS_MODEL_PATH=" + connectorClsModelPath);
	
	// Make sure connector end is singular, and it is connected to a port.
	inlogDebug("Checking if the connector is an assembly connector..."); 
	assert fatal (ec.IsAssemblyPortConnector()) with log("Connector " + ec.name + 
		" is not an assembly connector");
		
	// Create providing and requiring ports of the connector class
	inlog("Creating the connector class ports");
	var ports : List(Port) := ec.GetProvidingAndRequiringEndPorts();
	var requiringPort: Port := ports->at(1);
	var providingPort: Port := ports->at(2);
	
	var parts : List(Property) := ec.GetProvidingAndRequiringEndParts();
	var requiringPart : Property := parts->at(1);
	var providingPart : Property := parts->at(2);
	
	var providingPortConCls : Port := new Port("prvPort", 
		providingPort.type->oclAsType(Class)->asSequence()->at(1));
	connectorCls.ownedAttribute += providingPortConCls;
	
	var requiringPortConCls : Port := new Port("reqPort", 
		requiringPort.type->oclAsType(Class)->asSequence()->at(1));
	connectorCls.ownedAttribute += requiringPortConCls;
	
	var reqPortObj : Property := null;
	var requestPortCls : Class := null;
	
	inlog("Creating request port class and its ports");
	requestPortCls := new Class("RequestPortCls");
	connectorCls.nestedClassifier += requestPortCls;
	
	var providingPortReqPortCls : Port := new Port("prvPort", 
		providingPort.type->oclAsType(Class)->asSequence()->at(1));
	requestPortCls.ownedAttribute += providingPortReqPortCls;
					
	inlog("Creating Request Port object inside the connector class");
	reqPortObj := new Property('InPort');
	reqPortObj.type := requestPortCls;
	reqPortObj.lower := 1;
	reqPortObj.upper := 1;
	reqPortObj.isOrdered := true;
	reqPortObj.isUnique := false;
	connectorCls.ownedAttribute += reqPortObj.oclAsType(Property);
	
	inlog("Creating connector betweeen request port object and providing port of connector class");
	var inPortConClsConnector : Connector := new Connector("InPortConnector", providingPortConCls, 
									null, providingPortReqPortCls, reqPortObj); 
	connectorCls.ownedConnector += inPortConClsConnector;

	
	// Create connector object
	inlog("Creating the connector object...");  	
	var conObj := new Property('ConnectorObj');
	conObj.type := connectorCls;
	conObj.lower := 1;
	conObj.upper := 1;
	ownerClass.ownedAttribute += conObj.oclAsType(Property);
	
	inlog("Creating connectors between connector object and connected parts...");
	
	// Create required and provided side connectors and add them to the parent class
	var reqEndCon : Connector := new Connector(ec.name + "_reqEndCon", requiringPort, 
									requiringPart, providingPortConCls, conObj); 
	ownerClass.ownedConnector += reqEndCon;
	
	var prvEndCon : Connector := new Connector(ec.name + "_prvEndCon", requiringPortConCls, conObj, 
												providingPort, providingPart); 
	ownerClass.ownedConnector += prvEndCon;
	
	// Implement interface operation
	// Assumption: We assume that there is only one operation defined in the interface. 
	var theInterface : Interface = providingPort.provided->asSequence()->at(1);
	var theOperation : Operation = theInterface.ownedOperation->asSequence()->at(1);
	
	var newOperation : Operation = new Operation(theOperation);
	connectorCls.ownedOperation += newOperation;
	
	// Now, let's check if there are any dependencies from this primary enhanced connector to 
	// a secondary enhanced connector. 
	var elementsToRemove : List(Element);
	elementsToRemove += ec;
	
	var inOutPortMultiplicity : Integer := 1;
	
	if (ec.clientDependency->size() <> 0)
	{
		ec.clientDependency->forEach(e) 
		{			
			var target : Element = e.target->asSequence()->at(1);
			
			if (target->oclIsKindOf(Connector)->asSequence()->at(1))
			{
				var secondaryEnhancedConnector : Connector = e.target.oclAsType(Connector)
					->asSequence()->at(1);
				
				// Assumption: We assume that this secondary connector and primary connector
				// form a connected group. 
				assert fatal (secondaryEnhancedConnector.IsAssemblyPortConnector()) with 
					log("Connector " + secondaryEnhancedConnector.name + " is not an assembly connector");
				
				inlog("Processing secondary enhanced connector: " + secondaryEnhancedConnector.name);
					
				ports := secondaryEnhancedConnector.GetProvidingAndRequiringEndPorts();
				var requiringPortSecondary : Port := ports->at(1);
				var providingPortSecondary : Port := ports->at(2);
	
				parts := secondaryEnhancedConnector.GetProvidingAndRequiringEndParts();
				var requiringPartSecondary : Property := parts->at(1);
				var providingPartSecondary : Property := parts->at(2);
		
				
				if (conf = "SingleRequesterMultipleProvider")
				{
					// Make sure requiring part is the same as requiring part of the primary 
					// enhanced connector: 
					assert fatal (requiringPart = requiringPartSecondary) with
						log("Requiring parts of primary enhanced connector " + ec.name + " and " + 
							"secondary enhanced connector " + secondaryEnhancedConnector.name + 
							" are not same!");
				
					// Increase multiplicity of the requiring port of connector object by one 
					requiringPortConCls.lower := requiringPortConCls.lower + 1;
					requiringPortConCls.upper := requiringPortConCls.upper + 1;
	
					// Create another reqEnd connector from connector object to the providing part. 
					var prvEndConSec : Connector := new Connector(secondaryEnhancedConnector.name + 
						"_prvEndCon", requiringPortConCls, conObj, 
						providingPortSecondary, providingPartSecondary);
					ownerClass.ownedConnector += prvEndConSec;
				}
				else if (conf = "MultipleRequesterSingleProvider")
				{
					// Make sure providing part is the same as providing part of the primary 
					// enhanced connector: 
					assert fatal (providingPart = providingPartSecondary) with
						log("Providing parts of primary enhanced connector " + ec.name + " and " + 
							"secondary enhanced connector " + secondaryEnhancedConnector.name + 
							" are not same!");
					
					// Increase multiplicity of the providing port of connector object by one 
					providingPortConCls.lower := providingPortConCls.lower + 1;
					providingPortConCls.upper := providingPortConCls.upper + 1;
		
					// Increase multiplicity of the request port object by one
					reqPortObj.lower := reqPortObj.lower + 1;
					reqPortObj.upper := reqPortObj.upper + 1; 
		
					// Create another prvEnd connector from connector object to the providing part. 
					var reqEndConSec : Connector := new Connector(secondaryEnhancedConnector.name + 
						"_reqEndCon", providingPortConCls, conObj, 
						requiringPortSecondary, requiringPartSecondary);
					ownerClass.ownedConnector += reqEndConSec;
				};
				
				elementsToRemove += secondaryEnhancedConnector;
				
				inOutPortMultiplicity := inOutPortMultiplicity + 1;
			};
			
			elementsToRemove += e;
		}
	};
	
	if (conf = "SingleRequesterMultipleProvider")
	{
		inlog("OUTPORT_MULTIPLICITY=" + inOutPortMultiplicity.toString());
	}
	else if (conf = "MultipleRequesterSingleProvider")
	{
		inlog("INPORT_MULTIPLICITY=" + inOutPortMultiplicity.toString());	
	};
	
	// Create the OutPort attribute for Connector Class
	var outPortAttr : Property := new Property("OutPort");
	outPortAttr.type := theInterface;
	outPortAttr.isOrdered := true;
	outPortAttr.isUnique := false;
	 
	if (conf = "SingleRequesterMultipleProvider")
	{
		outPortAttr.lower := inOutPortMultiplicity;
		outPortAttr.upper := inOutPortMultiplicity;
	}
	else if (conf = "MultipleRequesterSingleProvider")
	{
		outPortAttr.lower := 1;
		outPortAttr.upper := 1;	
	};
	connectorCls.ownedAttribute += outPortAttr;
	
	// Map the activity which defines the connector behavior into a method 
	// of the connector class and its attributes, to attributes of the connector class. 
	var connectorBehaviorOpaqueBehavior : OpaqueBehavior = 
		ec.contract->oclAsType(OpaqueBehavior)->asSequence()->at(1);
	
	var requestBufferExists : Boolean := false;
	var requestBufferType : String := "SingleCopy";
	
	var replyBufferExists : Boolean := false;
	var replyBufferType : String := "SingleCopy";
	
	// For each property of the activity, create an attribute in the connector class
	// Since we are doing an inplace transformation, altering the owner of the attribute 
	// will suffice: 
	connectorBehaviorOpaqueBehavior.ownedAttribute->forEach(p) {
	
		// If the configuration is n:1 and this is a request buffer, create its copy inside
		// the requestPortCls. 
		if (p.hasStereotype("RequestBuffer") )
		{			
			requestPortCls.ownedAttribute += p;
			
			// and since multiplicity of this will now be governed by multiplicity of the 
			// requestPortCls object, set its multiplicity to 1: 
			p.lower := 1;
			p.upper := 1;
			
			// Set visibility of request buffer as public
			// so that connector class can access it:
			p.visibility := VisibilityKind::_public;
			
			requestBufferExists := true;
			
			var st : Stereotype := p.getAppliedStereotypes()->select(name = "RequestBuffer")
				->asSequence()->at(1);

			var bufferTypeLiteral : EnumerationLiteral := p.getValue(st, "type")
				.oclAsType(EnumerationLiteral);
			
			if (bufferTypeLiteral.name = "Fifo")
			{
				requestBufferType := "Fifo";
			}
			else if (bufferTypeLiteral.name = "SingleCopy")
			{
				requestBufferType := "SingleCopy";
				// set lower multiplicity to 0 to allow empty buffer semantics.
				p.lower := 0; 		
			};
			
			// Set the type of request buffer according to argument type of the operation
			// declared in the coordinated interface:  
			var parameter : Parameter := 
				theOperation.ownedParameter->select(direction != ParameterDirectionKind::_return)
				->asSequence()->at(1);
			
			// We set the parameter type regardless of buffer type, and will hangle Queue vs
			// primitive type decision in the next step in the transformation chain: 
			p.type := parameter.type;
		}
		else if (p.hasStereotype("ReplyBuffer"))
		{
			inlog("Setting multiplicity and return type of the reply buffer");
			
			// Set multiplicity of the reply buffer according to number of providers: 
			p.lower := inOutPortMultiplicity;
			p.upper := inOutPortMultiplicity;
			
			// Set type of the reply buffer according to the return type of the operation
			// declared in the coordinated interface: 
			// We set the parameter type regardless of buffer type, and will hangle Queue vs
			// primitive type decision in the next step in the transformation chain:
			var returnParam : Parameter := 
				theOperation.ownedParameter->select(direction = ParameterDirectionKind::_return)
				->asSequence()->at(1);
			p.type := returnParam.type;
			
			connectorCls.ownedAttribute += p;
			
			replyBufferExists := true;
			
			var st : Stereotype := p.getAppliedStereotypes()->select(name = "ReplyBuffer")
				->asSequence()->at(1);

			var bufferTypeLiteral : EnumerationLiteral := p.getValue(st, "type")
				.oclAsType(EnumerationLiteral);
			
			if (bufferTypeLiteral.name = "Fifo") 
			{
				replyBufferType := "Fifo";
			}	
			else if (bufferTypeLiteral.name = "SingleCopy")
			{
				requestBufferType := "SingleCopy";
			};
		}
		else
		{
			connectorCls.ownedAttribute += p;
		};
	};
	
	var opaqueBehaviorBody : String := connectorBehaviorOpaqueBehavior.body->asSequence()->at(1);
	
	var transformedOpaqueActionBody : String:= opaqueBehaviorBody
		->replaceAll("PRV_CNT", inOutPortMultiplicity.toString())
		->replaceAll("REQ_CNT", inOutPortMultiplicity.toString())
		->asSequence()->at(1);
	
	connectorBehaviorOpaqueBehavior.body := transformedOpaqueActionBody;
	connectorCls.ownedBehavior += connectorBehaviorOpaqueBehavior;
	newOperation.method += connectorBehaviorOpaqueBehavior;
	
	// Delete elements to remove in reverse direction
	elementsToRemove := elementsToRemove->reverse();
	elementsToRemove->forEach(elt)
	{
		// Debugger has a problem here, and after the first deletion, it does not
		// iterate over other elements, however, all elements in the list gets deleted. 
		e1Model.removeElement(elt);
	};
	
	CreateConnectorClsConstructor(
		connectorCls, 
		inOutPortMultiplicity);
	
	CreateRequestClassConstructor(
		requestPortCls,
		connectorCls, 
		requestBufferExists, 
		requestBufferType);
		
	CreateRequestPortClsRequestHandlerOperation(
		requestPortCls, 
		theOperation, 
		requestBufferExists, 
		requestBufferType);
		
	endLog("Done");
}


// Creates the constructor for the connector class and specifies its behavior using Alf. 
helper CreateConnectorClsConstructor(
	inout connectorCls:Class, 
	in inPortMultiplicity: Integer)
{
	var constructorOperation := new Operation(connectorCls.name);
	connectorCls.ownedOperation += constructorOperation;		

	var constructorBehavior : OpaqueBehavior := new OpaqueBehavior(connectorCls.name + "Behavior");
	
	constructorBehavior.language := "Alf";
	
	var constructorBehaviorStr : String = "";
	
	constructorBehaviorStr := 
		"Integer i = 1;" + "\n" + 
     	"while (i <= " + inPortMultiplicity.toString() + ") " + "\n" +
     	"{" + "\n" +
     	"    this.InPort[i] = new RequestPortCls(this);" + "\n" +
     	"    i = i + 1;" + "\n" +
     	"}" + "\n"; 
	
	constructorBehavior.body += constructorBehaviorStr;
	
	connectorCls.ownedBehavior += constructorBehavior;
	constructorOperation.method := constructorBehavior;
}


// Creates the constructor of the RequestPortClass and specifies its behavior using Alf. 
helper CreateRequestClassConstructor(
	inout requestPortCls:Class, 
	in connectorCls : Class, 
	in requestBufferExists : Boolean,
	in requestBufferType : String)
{
	var connClsAsAttribute : Property := new Property("ownerConnector");
	connClsAsAttribute.type := connectorCls;
	connClsAsAttribute.lower := 1;
	connClsAsAttribute.upper := 1;
	requestPortCls.ownedAttribute += connClsAsAttribute;
	
	var constructorOperation := new Operation(requestPortCls.name);
	requestPortCls.ownedOperation += constructorOperation;		

	var constructorParam : Parameter = new Parameter("c", connectorCls);
	constructorOperation.ownedParameter += constructorParam;

	var constructorBehavior : OpaqueBehavior := new OpaqueBehavior(requestPortCls.name + "Behavior");
	constructorBehavior.language := "Alf";

	var constructorBehaviorParam : Parameter = new Parameter("c", connectorCls);
	constructorBehavior.ownedParameter += constructorBehaviorParam;
	
	var constructorBehaviorStr : String = "";	
	constructorBehaviorStr := "this.ownerConnector  = c;" + "\n";

	if (requestBufferExists and requestBufferType = "Fifo")
	{
		constructorBehaviorStr := constructorBehaviorStr + 
			"this.RequestBuffer = new Queue<Integer>();" + "\n";
	};
	
	constructorBehavior.body += constructorBehaviorStr;

	requestPortCls.ownedBehavior += constructorBehavior;
	constructorOperation.method := constructorBehavior;
}


// Creates the request handling operation inside the RequestPortClass and 
// specifies its behavior using Alf. This handler operation is called the first whenever a 
// request has been made by one of the connected requesters.  
helper CreateRequestPortClsRequestHandlerOperation(
	inout requestPortCls:Class, 
	in otherRequestOperation: Operation, 
	in requestBufferExists : Boolean,
	in requestBufferType : String)
{
	var requestOperation := new Operation(otherRequestOperation);
	requestPortCls.ownedOperation += requestOperation;		

	var requestOperationBehavior : OpaqueBehavior := 
		new OpaqueBehavior(requestOperation.name + "Behavior");
	
	requestOperationBehavior.language := "Alf";
	
	var behaviorStr : String = "";
	
	// Assumption: we assume that the request operation has a single argument 
	// and a return value.
	var paramName : String := otherRequestOperation.ownedParameter->asSequence()->at(1).name;
	
	if (requestBufferExists)
	{
		if (requestBufferType = "SingleCopy")
		{
			behaviorStr := behaviorStr + 
				"// Store incoming request in request buffer" + "\n" +
				"this.RequestBuffer = " + paramName + ";" + "\n" +
				"\n";
		}
		else
		{
			behaviorStr := behaviorStr +
				"// Store incoming request in request buffer" + "\n" +
				"this.RequestBuffer.add(" + paramName + ");" + "\n" +
				"\n";	
		}
	};
	
	behaviorStr := behaviorStr + 
		"// Let connector object process the request" + "\n" +
        "return this.ownerConnector." + otherRequestOperation.name + 
        		"(" + paramName + ");" + "\n";
	
	requestOperationBehavior.body += behaviorStr;
	requestPortCls.ownedBehavior += requestOperationBehavior;
	requestOperation.method := requestOperationBehavior;
}


constructor OpaqueBehavior::OpaqueBehavior(nameArg:String) {
	name := nameArg;
}


// A plain class in our terms is a class which has no nesterd classifiers and no ports. 
query Class::IsPlainClass() : Boolean =
	self.nestedClassifier->size() = 0 and self.ownedPort->size() = 0;


constructor Class::Class(nameArg:String)
{
	name := nameArg; 
}


constructor Property::Property(nameArg:String) {
	name := nameArg;
}


constructor Port::Port(nameArg:String, typeArg:Class) {
	name := nameArg;
	type := typeArg;
}


constructor ConnectorEnd::ConnectorEnd(portArg: Port, partWithPortArg: Property)
{
	role := portArg;
	partWithPort := partWithPortArg;	
}


constructor Connector::Connector(nameArg: String, port1: Port, partWithPort1: Property, 
								 port2: Port, partWithPort2: Property) {
	name := nameArg;
	_end += new ConnectorEnd(port1, partWithPort1);
	_end += new ConnectorEnd(port2, partWithPort2);	
}


constructor Operation::Operation(otherOperation: Operation) {
	name := otherOperation.name;
	
	otherOperation.ownedParameter->forEach(otherParam) {
		var newParam = new Parameter(otherParam);
		ownedParameter += newParam; 
	}
}


constructor Operation::Operation(nameArg : String) {
	name := nameArg;
}


constructor Parameter::Parameter(otherParam: Parameter) {
	name := otherParam.name;
	
	type := otherParam.type;
	
	direction := otherParam.direction;
}

constructor Parameter::Parameter(nameArg: String, typeArg : Type) {
	name := nameArg; 
	type := typeArg;
}


// Create a new activity using the connector behavior activity
constructor Activity::Activity(nameArg: String) {
	name := nameArg;
}


constructor OpaqueAction ::OpaqueAction(otherOpaqueAction: OpaqueAction) {
	name := otherOpaqueAction.name;
	body := otherOpaqueAction.body;
}


constructor InitialNode:: InitialNode(argName : String) {
	name := argName;
}


constructor ActivityFinalNode :: ActivityFinalNode(argName : String) {
	name := argName;
}


constructor ControlFlow :: ControlFlow(sourceArg : ActivityNode, targetArg : ActivityNode) {
	source := sourceArg;
	target := targetArg; 
}


// check if connector has two ends, 
// and both ends are connected to ports 
// and partWithPort fields are populated as well. Also checks our assumptions related to 
// number of provided/required interfaces. 
query Connector::IsAssemblyPortConnector() : Boolean = 
	self._end->size() = 2 and 
	self._end->at(1)->role->size() = 1 and 
	self._end->at(1)->role->oclIsKindOf(Port)->asSequence()->at(1) and
	self._end->at(1)->partWithPort->size() = 1 and
	self._end->at(1)->partWithPort->oclIsKindOf(Property)->asSequence()->at(1) and
	 
	self._end->at(2)->role->size() = 1 and   
	self._end->at(2)->role->oclIsKindOf(Port)->asSequence()->at(1) and
	self._end->at(2)->partWithPort->size() = 1 and
	self._end->at(2)->partWithPort->oclIsKindOf(Property)->asSequence()->at(1) and 

	// Check if either provided or required interfaces of either side match and number of 
	// provided required interfaces are the same	
	( (self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->provided->size() = 1 and 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->required->size() = 1 and
	   self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->provided->asSequence()->at(1) = 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->required->asSequence()->at(1) )     or
	  
	  (self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->required->size() = 1 and 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->provided->size() = 1 and
 	   self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->required->asSequence()->at(1) = 
 	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->provided->asSequence()->at(1) ) );  



// Precond: self.IsAssemblyPortConnector
query Connector::GetProvidingAndRequiringEndPorts() : List(Port) {
	var port1 : Port := self._end->at(1)->role->oclAsType(Port)->asSequence()->at(1);
	var port2 : Port := self._end->at(2)->role->oclAsType(Port)->asSequence()->at(1);
	
	if (port1.required->size() = 1) {
		return List {port1, port2};	
	}
	else {
		return List {port2, port1};
	};
}


// Precond: self.IsAssemblyPortConnector
// returns two element set {RequiringPort, ProvidingPort}
query Connector::GetProvidingAndRequiringEndParts() : List(Property) {
	var port1 : Port := self._end->at(1)->role->oclAsType(Port)->asSequence()->at(1);
	var port2 : Port := self._end->at(2)->role->oclAsType(Port)->asSequence()->at(1);
		
	var part1 : Property := self._end->at(1)->partWithPort->oclAsType(Property)->asSequence()->at(1);
	var part2 : Property := self._end->at(2)->partWithPort->oclAsType(Property)->asSequence()->at(1);
	
	if (port1.required->size() = 1) {
		return List {part1, part2};	
	}
	else {
		return List {part2, part1};
	};
}


// If the connector has "contract", this should return true. 
query Connector::isPrimaryEnhancedConnector() : Boolean = (self.contract->size() = 1);


// If a primary connector has a dependency to this connector, this should return true. 
query Connector::isSecondaryEnhancedConnector() : Boolean {

	if (self.isPrimaryEnhancedConnector())
		return false;
	
	
		var s : Set(Relationship) = self.getRelationships();
		 
		self.getRelationships()->forEach(r | r->oclIsKindOf(Dependency)->asSequence()->at(1)) {
			
			var dependency : Dependency = r->oclAsType(Dependency)->asSequence()->at(1);
			
			if (dependency.target->asSequence()->at(1) = self)
			{
				return true;	
			}
			
		};
		
	return false; 
}
