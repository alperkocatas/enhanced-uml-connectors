// This is an inplace transformation, which is ran from inside Java to save outputs as a different
// model file. 

import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

transformation E1toE2Transformation(inout e1Model:uml)
	access EcTransformationLibrary;

main() {
	initializeLogger();
	beginLog("Starting E1 to E2 Transformation...");	
	transformE1toE2();
	endLog("Done");
}

helper transformE1toE2()
{
	var model : Model := e1Model.rootObjects()[Model]->asSequence()->at(1);
	
	// Search for enhanced connectors inside the model 
	var allStuff : Set(Element) := model->allOwnedElements()
		->asSequence()->at(1);
	
	allStuff->forEach(e) {
		
		if (e->oclIsKindOf(Connector)->asSequence()->at(1) = true)
		{
			var con : Connector = e->oclAsType(Connector)->asSequence()->at(1); 
			
			if (con.isPrimaryEnhancedConnector() )
			{
				inlog("Found a primary enhanced connector: " + con.name);
				transformPrimaryEnhancedConnector(con);
				
				// For simplicity, let's assume that the model contains at most one 
				// enhanced connector. So, break after transforming it. 
				break;
			};
		};		
	};
}


helper transformPrimaryEnhancedConnector(ec : Connector)
{
	beginLog(">> begin: Processing " + ec.name + " as Primary Enhanced Connector");
	
	var ownerClass : Class := ec.owner->oclAsType(Class)->asSequence()->at(1);
	
	var connectorCls : Class := new Class(ec.name + "_ConnectorCls");
	
	ownerClass.nestedClassifier += connectorCls;
	
	var connectorClsModelPath : String := getModelPath(connectorCls);
	inlog("CONNECTOR_CLS_MODEL_PATH=" + connectorClsModelPath);
	
	// Make sure connector end is singular, and it is connected to a port.
	inlog("Checking if the connector is an assembly connector..."); 
	assert fatal (ec.IsAssemblyPortConnector()) with log("Connector " + ec.name + 
		" is not an assembly connector");
		
	// Create providing and requiring ports of the connector class
	inlog("Creating the connector class ports...");
	var ports : List(Port) := ec.GetProvidingAndRequiringEndPorts();
	var requiringPort: Port := ports->at(1);
	var providingPort: Port := ports->at(2);
	
	var parts : List(Property) := ec.GetProvidingAndRequiringEndParts();
	var requiringPart : Property := parts->at(1);
	var providingPart : Property := parts->at(2);
	
	// now, can we just use the reguar type? dont' we need any resolve? well let's try...
	
	//var providerPortType : Class := providingPort.type.resolveoneIn(Class::PlainClass2Class, Class);
	var providingPortConCls : Port := new Port("prvPort", 
		providingPort.type->oclAsType(Class)->asSequence()->at(1));
	connectorCls.ownedAttribute += providingPortConCls;
	
	//var requiringPortType : Class := requiringPort.type.resolveoneIn(Class::PlainClass2Class, Class);
	var requiringPortConCls : Port := new Port("reqPort", 
		requiringPort.type->oclAsType(Class)->asSequence()->at(1));
	connectorCls.ownedAttribute += requiringPortConCls;
	
	// Create connector object
	inlog("Creating the connector object...");  	
	var conObj := new Property('ConnectorObj');
	conObj.type := connectorCls;
	conObj.lower := 1;
	conObj.upper := 1;
	ownerClass.ownedAttribute += conObj.oclAsType(Property);
	
	// Connect the providing port of the connector class to the 
	// requiring port connected to the connector in the source model:
	inlog("Creating connectors betwee connector object and connected parts...");
	
	// Create required and provided side connectors and add them to the parent class
	var reqEndCon : Connector := new Connector(ec.name + "_reqEndCon", requiringPort, 
									requiringPart, providingPortConCls, conObj); 
	ownerClass.ownedConnector += reqEndCon;
	
	var prvEndCon : Connector := new Connector(ec.name + "_prvEndCon", requiringPortConCls, conObj, 
												providingPort, providingPart); 
	ownerClass.ownedConnector += prvEndCon;
	
	// Implement interface operation
	// TODO: Assumption: We assume that there is only one operation defined in the interface. 
	var theInterface : Interface = providingPort.provided->asSequence()->at(1);
	var theOperation : Operation = theInterface.ownedOperation->asSequence()->at(1);
	
	var newOperation : Operation = new Operation(theOperation);
	connectorCls.ownedOperation += newOperation;
	
	// Now, let's check if there are any dependencies from this primary enhanced connector to 
	// a secondary enhanced connector. 
	
	var elementsToRemove : List(Element);
	elementsToRemove += ec;
	
	var outPortMultiplicity : Integer := 1;
	
	if (ec.clientDependency->size() <> 0)
	{
		ec.clientDependency->forEach(e) 
		{			
			var target : Element = e.target->asSequence()->at(1);
			
			if (target->oclIsKindOf(Connector)->asSequence()->at(1))
			{
				var secondaryEnhancedConnector : Connector = e.target.oclAsType(Connector)
					->asSequence()->at(1);
				
				// TODO: Assumption: We assume that this secondary connector and primary connector
				// form a connected group. 
				assert fatal (secondaryEnhancedConnector.IsAssemblyPortConnector()) with 
					log("Connector " + ec.name + " is not an assembly connector");
				
				inlog("Processing secondary enhanced connector: " + secondaryEnhancedConnector.name);
					
				ports := secondaryEnhancedConnector.GetProvidingAndRequiringEndPorts();
				var requiringPortSecondary : Port := ports->at(1);
				var providingPortSecondary : Port := ports->at(2);
	
				parts := secondaryEnhancedConnector.GetProvidingAndRequiringEndParts();
				var requiringPartSecondary : Property := parts->at(1);
				var providingPartSecondary : Property := parts->at(2);
				
				// make sure requiring part is the same as requiring part of the primary enhanced 
				// connector: 
				// TODO: This is specific.. only for one to many configurations. 
				assert fatal (requiringPart = requiringPartSecondary) with
					log("Requiring parts of primary enhanced connector " + ec.name + " and " + 
						"secondary enhanced connector " + secondaryEnhancedConnector.name + 
						" are not same!");
				
				// Increase multiplicity of the requiring port of connector object by one. 
				requiringPortConCls.lower := requiringPortConCls.lower + 1;
				requiringPortConCls.upper := requiringPortConCls.upper + 1;
	
				// Now, create another reqEnd connector from connector object to the providing part. 
				var prvEndConSec : Connector := new Connector(secondaryEnhancedConnector.name + 
					"_prvEndCon", requiringPortConCls, conObj, 
					providingPortSecondary, providingPartSecondary);
				ownerClass.ownedConnector += prvEndConSec;
				
				elementsToRemove += secondaryEnhancedConnector;
				
				outPortMultiplicity := outPortMultiplicity + 1;
			};
			
			elementsToRemove += e;
		}
	};
	
	inlog("OUTPORT_MULTIPLICITY=" + outPortMultiplicity.toString());
	
	// Map the activity which defines the connector behavior into a method 
	// of the connector class and its attributes, to attributes of the connector class. 
	
	// Let's locate the "contract" of the primary enhanced connector first: 
	var connectorBehaviorActivity : Activity = ec.contract->oclAsType(Activity)->asSequence()->at(1);
	
	// Foreach property of the activity, create an attribute in the connector class
	connectorBehaviorActivity.ownedAttribute->forEach(p) {
	
		var newProperty : Property = new Property(p.name);
		// TODO: make sure type of the property is a primitive type, 
		// otherwise, this will require a deeper copy.
		newProperty.type := p.type;
		connectorCls.ownedAttribute += newProperty;
	};
	
	elementsToRemove += connectorBehaviorActivity;
	
	// Assumption: The connector behavior activity consists of:
	// - Initial node 
	// - Opaque action
	// - Final node
	// - Transitions in between

	// Copy the connector behavior activity 
	// TODO: Revise: Since we are doing an inplace transformation now, We may not have to make 
	// this duplication. We can just move existing activity
	// inside the connector class, and move the attributes to the connector class. 
	var newConnectorBehaviorActivity : Activity = new Activity(connectorBehaviorActivity.name);
	newConnectorBehaviorActivity.visibility := VisibilityKind::package;
	
	
	// Find the opaque action inside the activity and create a copy of it 
	var opaqueAction : OpaqueAction := 
		connectorBehaviorActivity.ownedElement->select(oa | oa.oclIsKindOf(OpaqueAction))
			->oclAsType(OpaqueAction)->asSequence()->at(1);
	assert fatal(opaqueAction <> null) with log("No OpaqueAction was found under connector behavior");
	var newOpaqueAction : OpaqueAction = new OpaqueAction(opaqueAction);
	newConnectorBehaviorActivity.ownedNode += newOpaqueAction;
	
	
	// create initial node and final nodes
	var newInitialNode : InitialNode = new InitialNode("initialNode");
	newConnectorBehaviorActivity.ownedNode += newInitialNode;
	
	var newActivityFinalNode : ActivityFinalNode = new ActivityFinalNode("finalNode");
	newConnectorBehaviorActivity.ownedNode += newActivityFinalNode;
	
	// create control flows between initial node, opaque action and activity final nodes:
	var controlFlow1 : ControlFlow = new ControlFlow(newInitialNode, newOpaqueAction);
	newConnectorBehaviorActivity.edge += controlFlow1;
	var controlFlow2 : ControlFlow = new ControlFlow(newOpaqueAction, newActivityFinalNode);
	newConnectorBehaviorActivity.edge += controlFlow2;
	
	connectorCls.ownedBehavior += newConnectorBehaviorActivity;
	
	newOperation.method += newConnectorBehaviorActivity;
	
	
	// Delete elements to remove in reverse direction
	elementsToRemove := elementsToRemove->reverse();
	elementsToRemove->forEach(elt)
	{
		// Strangely, debugger has a problem here, and after the first deletion, it does not
		// iterate over other elements, however, all elements in the list gets deleted. 
		e1Model.removeElement(elt);
	};
		
	endLog("Done");
}


query Class::IsPlainClass() : Boolean =
	self.nestedClassifier->size() = 0 and self.ownedPort->size() = 0;

constructor Class::Class(nameArg:String)
{
	name := nameArg; 
}

constructor Property::Property(nameArg:String) {
	name := nameArg;
}

constructor Port::Port(nameArg:String, typeArg:Class) {
	name := nameArg;
	type := typeArg;
}

constructor ConnectorEnd::ConnectorEnd(portArg: Port, partWithPortArg: Property)
{
	role := portArg;
	partWithPort := partWithPortArg;	
}

constructor Connector::Connector(nameArg: String, port1: Port, partWithPort1: Property, 
								 port2: Port, partWithPort2: Property) {
	name := nameArg;
	_end += new ConnectorEnd(port1, partWithPort1);
	_end += new ConnectorEnd(port2, partWithPort2);	
}

constructor Operation::Operation(otherOperation: Operation) {
	name := otherOperation.name;
	
	otherOperation.ownedParameter->forEach(otherParam) {
		var newParam = new Parameter(otherParam);
		ownedParameter += newParam; 
	}
}

constructor Parameter::Parameter(otherParam: Parameter) {
	name := otherParam.name;
	
	 
	// this might require a deeper resolve operation. 
	type := otherParam.type;
}

// Create a new activity using the connector behavior activity
constructor Activity::Activity(nameArg: String) {
	name := nameArg;
}

constructor OpaqueAction ::OpaqueAction(otherOpaqueAction: OpaqueAction) {
	name := otherOpaqueAction.name;
	body := otherOpaqueAction.body;
}

constructor InitialNode:: InitialNode(argName : String) {
	name := argName;
}

constructor ActivityFinalNode :: ActivityFinalNode(argName : String) {
	name := argName;
}

constructor ControlFlow :: ControlFlow(sourceArg : ActivityNode, targetArg : ActivityNode) {
	source := sourceArg;
	target := targetArg; 
}


// check if connector has two ends, 
// and both ends are connected to ports 
// and partWithPort fields are populated as well  
query Connector::IsAssemblyPortConnector() : Boolean = 
	self._end->size() = 2 and 
	self._end->at(1)->role->size() = 1 and 
	self._end->at(1)->role->oclIsKindOf(Port)->asSequence()->at(1) and
	self._end->at(1)->partWithPort->size() = 1 and
	self._end->at(1)->partWithPort->oclIsKindOf(Property)->asSequence()->at(1) and
	 
	self._end->at(2)->role->size() = 1 and   
	self._end->at(2)->role->oclIsKindOf(Port)->asSequence()->at(1) and
	self._end->at(2)->partWithPort->size() = 1 and
	self._end->at(2)->partWithPort->oclIsKindOf(Property)->asSequence()->at(1) and 

	// Check if either provided or required interfaces of either side match and number of 
	// provided required interfaces are the same	
	( (self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->provided->size() = 1 and 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->required->size() = 1 and
	   self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->provided->asSequence()->at(1) = 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->required->asSequence()->at(1) )     or
	  
	  (self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->required->size() = 1 and 
	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->provided->size() = 1 and
 	   self._end->at(1)->role->asSequence()->at(1)->oclAsType(Port)->required->asSequence()->at(1) = 
 	   self._end->at(2)->role->asSequence()->at(1)->oclAsType(Port)->provided->asSequence()->at(1) ) );  


// Precond: self.IsAssemblyPortConnector
query Connector::GetProvidingAndRequiringEndPorts() : List(Port) {
	var port1 : Port := self._end->at(1)->role->oclAsType(Port)->asSequence()->at(1);
	var port2 : Port := self._end->at(2)->role->oclAsType(Port)->asSequence()->at(1);
	
	if (port1.required->size() = 1) {
		return List {port1, port2};	
	}
	else {
		return List {port2, port1};
	};
}

// Precond: self.IsAssemblyPortConnector
// returns two element set {RequiringPort, ProvidingPort}
query Connector::GetProvidingAndRequiringEndParts() : List(Property) {
	var port1 : Port := self._end->at(1)->role->oclAsType(Port)->asSequence()->at(1);
	var port2 : Port := self._end->at(2)->role->oclAsType(Port)->asSequence()->at(1);
		
	var part1 : Property := self._end->at(1)->partWithPort->oclAsType(Property)->asSequence()->at(1);
	var part2 : Property := self._end->at(2)->partWithPort->oclAsType(Property)->asSequence()->at(1);
	
	if (port1.required->size() = 1) {
		return List {part1, part2};	
	}
	else {
		return List {part2, part1};
	};
}

// If the connector has "contract", this should return true. 
query Connector::isPrimaryEnhancedConnector() : Boolean = (self.contract->size() = 1);

// If a primary connector has a dependency to this connector, this should return true. 
query Connector::isSecondaryEnhancedConnector() : Boolean {

	if (self.isPrimaryEnhancedConnector())
		return false;
	
	
		var s : Set(Relationship) = self.getRelationships();
		 
		self.getRelationships()->forEach(r | r->oclIsKindOf(Dependency)->asSequence()->at(1)) {
			
			var dependency : Dependency = r->oclAsType(Dependency)->asSequence()->at(1);
			
			if (dependency.target->asSequence()->at(1) = self)
			{
				return true;	
			}
			
		};
		
	return false; 
}


