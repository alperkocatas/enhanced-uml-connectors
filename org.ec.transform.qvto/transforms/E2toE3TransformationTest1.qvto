modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');


// The plan is to take as input two uml models, and output another uml model 
transformation E2toE3TransformationTest1(inout e2Model:uml, in fUmlModel:uml);

configuration property IFC_NAME : String;
configuration property OP_NAME : String;
configuration property CONNECTOR_CLS_NAME : String;
configuration property IFC_ASSOC_NAME : String;
configuration property IFC_ASSOC_MULTIPLICITY : Integer;
configuration property CONTAINER_CLS_NAME : String;
configuration property FUML_CONNECTOR_ACTIVITY_NAME : String;
configuration property FUML_MODEL_REF_PATH_STR : String;
configuration property FUML_CONTAINER_PKG_NAME : String;

configuration property LogIndentLevel : Integer;

helper setDefaultConfigurationPropertyValues() {
	
	if (IFC_NAME = null)
		IFC_NAME := "XIfc";
	
	if (OP_NAME = null)
		OP_NAME := "xOp";
	
	if (CONNECTOR_CLS_NAME = null)
		CONNECTOR_CLS_NAME := "ConnectorCls";
			
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "ItsXIfc";

	if (IFC_ASSOC_MULTIPLICITY = null)
		IFC_ASSOC_MULTIPLICITY := 2;
		
	if (CONTAINER_CLS_NAME = null)
		CONTAINER_CLS_NAME := "ECls";
	
	if (FUML_CONNECTOR_ACTIVITY_NAME = null)
		FUML_CONNECTOR_ACTIVITY_NAME := "xOp$method$1";
		
	if (FUML_MODEL_REF_PATH_STR = null)
		FUML_MODEL_REF_PATH_STR := "PortModel6_RoundRobinConnector";
	
	if (FUML_CONTAINER_PKG_NAME = null)
		FUML_CONTAINER_PKG_NAME := "PortModel6_RoundRobinConnector"; 	
}


main() {
	LogIndentLevel := 0;
	log('In Main ');

	// can we just write a huge helper function which will do all the manipulation? 
	transformE2toE3();	
}

constructor Property::Property(nameArg:String, typeArg : Interface, 
							  lowerArg: Integer, upperArg: Integer) {
	name := nameArg;
	type := typeArg;
	lower := lowerArg;
	upper := upperArg;
}

helper transformE2toE3()  {

	setDefaultConfigurationPropertyValues();
	
	var arg : String := e2Model.rootObjects()[Model].name->asSequence()->at(1);
	
	log("got this in the e2Model: " + arg);
	
	var arg2 : String := fUmlModel.rootObjects()[Model].name->asSequence()->at(1);
	log("got this in the fUmlModel: " + arg2);

	var fUmlModel : Model := fUmlModel.rootObjects()[Model]->asSequence()->at(1);
	
	var fUmlPkg : Package := fUmlModel.packagedElement
		->select(name = FUML_CONTAINER_PKG_NAME)
		->oclAsType(Package)->asSequence()->at(1);
						      
	var fUmlConCls : Class := fUmlPkg.packagedElement
		->select(name = CONNECTOR_CLS_NAME)
		->oclAsType(Class)->asSequence()->at(1);
														
	var fUmlConnectorBehaviorActivity : Activity := fUmlConCls.ownedBehavior
		->select(name = FUML_CONNECTOR_ACTIVITY_NAME)
		->oclAsType(Activity)->asSequence()->at(1);
				
	// now, let's locate the connector class inside the e2 model: 
	var e2ModelElt : Model := e2Model.rootObjects()[Model]->asSequence()->at(1);
	
	var e2ContainerCls : Class := e2ModelElt.packagedElement
		->select(name = CONTAINER_CLS_NAME)
		->oclAsType(Class)->asSequence()->at(1);
		
	var e2ConCls : Class := e2ContainerCls.nestedClassifier
		->select(name = CONNECTOR_CLS_NAME)->oclAsType(Class)->asSequence()->at(1);
	
	var e2xOp : Operation := e2ConCls.ownedOperation->select(name = OP_NAME)
		->oclAsType(Operation)->asSequence()->at(1);
	
	var e2xIfc : Interface := e2ModelElt.packagedElement
		->select(name = IFC_NAME)->oclAsType(Interface)->asSequence()->at(1);
	
	// Create the ItsXIfc reference array: 
	var foundCount : Integer := e2ConCls[Class].allAttributes()
					->collect(name = IFC_ASSOC_NAME)->count(true);
	
	var e2ItsXIfc : Property;			
	if (foundCount = 0)
	{
		e2ItsXIfc := new Property(IFC_ASSOC_NAME, e2xIfc, 
			IFC_ASSOC_MULTIPLICITY, IFC_ASSOC_MULTIPLICITY);
		e2ConCls.ownedAttribute += e2ItsXIfc;
	}
	else if (foundCount = 1)
	{
		e2ItsXIfc := e2ConCls[Class].allAttributes()
			->select(name = IFC_ASSOC_NAME)->oclAsType(Property)->asSequence()->at(1);
	}
	else
	{
		log("WARNING: property " + IFC_ASSOC_NAME + " is defined more than once under class " + 
			e2ConCls.name);
	};
	
	var newActivity: Activity = fUmlConnectorBehaviorActivity[Activity]
		->deepclone()->asSequence()->at(1);
	
	e2ConCls.ownedBehavior += newActivity;
	
	// Delete existing method of e2xOp;
	if (e2xOp.method != null)
	{
		e2Model.removeElement(e2xOp.method.oclAsType(Element)->asSequence()->at(1));
	};
	
	// Set specification of the newActivity to xOp in the e2 model. 
	newActivity.specification := e2xOp;
	
	var allStuff : Set(Element) := newActivity[Activity]->allOwnedElements()
		->asSequence()->at(1);
	
	var count : Integer := 0; 
	allStuff->forEach(e) {
		
		if (e.oclIsKindOf(StructuralFeatureAction))
		{
			var sfa : StructuralFeatureAction = e.oclAsType(StructuralFeatureAction);
			
			var sfname : String := sfa.structuralFeature.name;
			var sfqualifiedName : String := sfa.structuralFeature.qualifiedName;
			
			var idx : Integer := sfqualifiedName.indexOf(FUML_MODEL_REF_PATH_STR);  
			if (idx > 0)
			{
				log("Found: StructuralFeatureAction: " + sfqualifiedName);
				count := count + 1; 	
				
				// Now, we should do a name resolution here. 
				// Try to find the structuralFeature in the connectorClass. 
				foundCount := e2ConCls[Class].allAttributes()
					->collect(name = sfname)->count(true);
				
				if (foundCount != 1)
				{ 
					log("WARNING: Expected to find exactly 1 attribute with name " + sfname + 
						" under class " + e2ConCls.qualifiedName  + " but found " + 
						foundCount.toString());
				}
				else
				{
					var e2Property : Property := e2ConCls[Class].allAttributes()
						->select(name = sfname)->oclAsType(Property)->asSequence()->at(1);
												 	
					// Now, let's alter the structural feature to this one. 
					sfa.structuralFeature := e2Property;
					log("Updated structuralFeature field of StructuralFeatureAction " + 
						sfqualifiedName);
				}
			};   
			
			sfa.input->forEach(inputPin) {
				
				if (inputPin.type.qualifiedName.indexOf(FUML_MODEL_REF_PATH_STR) > 0)
				{
					if (inputPin.type.name = e2ConCls.name) 
					{
						inputPin.type := e2ConCls;
						log("Updated inputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2ConCls.name);
					}
				}
				else if (inputPin.type.name = e2xIfc.name)
				{
					inputPin.type := e2xIfc;
					log("Updated inputPin.type field of StructuralFeatureAction " + 
						sfqualifiedName + " as " + e2xIfc.name);	
				}
			};
			
			sfa.output->forEach(outputPin) {
				
				if (outputPin.type.qualifiedName.indexOf(FUML_MODEL_REF_PATH_STR) > 0) 
				{
					if (outputPin.type.name = e2ConCls.name)
					{
						outputPin.type := e2ConCls;
						log("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2ConCls.name);
					}
					else if (outputPin.type.name = e2xIfc.name)
					{
						outputPin.type := e2xIfc;
						log("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2xIfc.name);	
					}
				}	
			};
			
			
		}
		else if (e.oclIsKindOf(ReadSelfAction)) 
		{
			var rsa : ReadSelfAction := e.oclAsType(ReadSelfAction);
			var rsaResultTypeQualifiedName : String := rsa.result.type.qualifiedName;
			
			if (rsaResultTypeQualifiedName.indexOf(FUML_MODEL_REF_PATH_STR) > 0)
			{
				log("Found: ReadSelfAction result.type: " + rsaResultTypeQualifiedName);
				count := count + 1; 
				
				var rsaResultTypeName : String := rsa.result.type.name;
				
				// Now, should we be specific about it and assume that the type is 
				// of ConnectorCls? 
				// TODO: may require revising
				if (rsaResultTypeName = e2ConCls.name)
				{
					rsa.result.type := e2ConCls;
					log("Updated result.type field of ReadSelfAction: " + rsa.name);
				}
			}
		}
		else if (e.oclIsKindOf(CallOperationAction))
		{
			var coa : CallOperationAction := e.oclAsType(CallOperationAction);
			var coaOpQualifiedName = coa.operation.qualifiedName;
			
			if (coaOpQualifiedName.indexOf(FUML_MODEL_REF_PATH_STR) > 0)
			{
				log("Found: CallOperation operation: " + coaOpQualifiedName);
				
				var coaOpName := coa.operation.name;
				
				if (coaOpName = e2xOp.name)
				{
					log("Updating operation field of CallOperationAction: " + coa.name);
					coa.operation := e2xOp;
					count := count + 1;
				}
				
			};
			
			var coaTargetTypeQName : String := coa.target.type.qualifiedName;
			 
			if (coaTargetTypeQName.indexOf(FUML_MODEL_REF_PATH_STR) > 0)
			{
				log("Found: CallOperation target type: " + coaTargetTypeQName);
				
				var coaTargetTypeName : String := coa.target.type.name;
				if (coaTargetTypeName = e2ConCls.name)
				{
					log("Updating target.type field of CallOperationAction: " + coa.name +
						" as " + e2xIfc.name);
					coa.target.type := e2ConCls;
					count := count + 1;
				}
				else if (coaTargetTypeName = e2xIfc.name)
				{
					log("Updating target.type field of CallOperationAction: " + coa.name + 
						" as " + e2xIfc.name);
					coa.target.type := e2xIfc;
					count := count + 1;
				}
			}
		}
	};
	
	log("Replaced " + count.toString() + " references");
	
		
}


helper getLogIndent() : String {
	var indentStr : String := '';
	var i : Integer := 0;
	
	while (i < LogIndentLevel) {
		indentStr := indentStr + ' ';
		i := i + 1;
	};
	
	return indentStr;
}

helper beginLog(arg: String) {
	var indentStr = getLogIndent();
	log(indentStr + '>> Begin transforming ' + arg);
	LogIndentLevel := LogIndentLevel + 2;
}

helper inlog(arg: String) {
	var indentStr = getLogIndent();
	log(indentStr + " " + arg);
}

helper endLog(arg: String) {
	LogIndentLevel := LogIndentLevel - 2;
	var indentStr = getLogIndent();
	log(indentStr + '<< End transforming ' + arg);
}
