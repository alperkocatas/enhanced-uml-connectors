import EcTransformationLibrary;

modeltype uml "strict" uses uml('http://www.eclipse.org/uml2/5.0.0/UML');


// The plan is to take as input two uml models, and output another uml model 
transformation E2toE3Transformation(inout e2Model:uml, in fUmlModel:uml) 
	access EcTransformationLibrary;

configuration property CONNECTOR_CLS_MODEL_PATH : String;
configuration property OUTPORT_MULTIPLICITY : Integer;
configuration property ALF_PKG_NAME : String;

configuration property IFC_ASSOC_NAME : String;
configuration property LogIndentLevel : Integer;

helper checkConfigurationPropertyValues() {
			
	if (IFC_ASSOC_NAME = null)
		IFC_ASSOC_NAME := "OutPort";
		
	assert fatal (CONNECTOR_CLS_MODEL_PATH <> null) with 
		log("CONNECTOR_CLS_MODEL_PATH parameter is mandatory");
	
	assert fatal (OUTPORT_MULTIPLICITY <> null) with 
		log("OUTPORT_MULTIPLICITY parameter is mandatory");
				
	assert fatal (ALF_PKG_NAME <> null) with 
		log("ALF_PKG_NAME parameter is mandatory");
}


main() {
	initializeLogger();
	beginLog('Starting E2 to E3 transformation');

	// can we just write a huge helper function which will do all the manipulation? 
	transformE2toE3();
	
	endLog('Done');	
}

constructor Property::Property(nameArg:String, typeArg : Interface, 
							  lowerArg: Integer, upperArg: Integer) {
	name := nameArg;
	type := typeArg;
	lower := lowerArg;
	upper := upperArg;
}


// We are searching for an activity like name "xOp$method$1";
// and we want to skip names like destroy$method$1, ConnectorCls$method$1, 
// ConnectorCls$initialization$1... 
helper findConnectorBehaviorActivity(fUmlConCls: Class) : Activity {
														
	var behaviorSet : Set(Behavior) := fUmlConCls.ownedBehavior
		->select(name.indexOf(fUmlConCls.name +"$") <= 0 and 
				 name.indexOf("destroy" + "$") <= 0);
		
	assert fatal (behaviorSet->size() = 1) with 
		log("fUML class " + fUmlConCls.name + " has more than one activities for connector " + 
		    "behavior candidate!");	
		
	var fUmlConnectorBehaviorActivity : Activity := 
		behaviorSet->oclAsType(Activity)->asSequence()->at(1);
	
	return fUmlConnectorBehaviorActivity;
}


helper transformE2toE3()  {

	checkConfigurationPropertyValues();
	
	beginLog("Locating e2 model elements...");
	
	// now, let's locate the connector class inside the e2 model: 
	var e2ModelElt : Model := e2Model.rootObjects()[Model]->asSequence()->at(1);
	
	var allObjects : Set(Element) := e2Model.rootObjects()->oclAsType(Element)->asSet();
		
	var e2ConCls : Class := getModelElement(CONNECTOR_CLS_MODEL_PATH, e2Model)
		->oclAsType(Class)->asSequence()->at(1);
	
	assert fatal (e2ConCls <> null) with
		log("Could not find class " + CONNECTOR_CLS_MODEL_PATH + " in input model");
	
	var e2ContainerCls : Class := e2ConCls.owner->oclAsType(Class)->asSequence()->at(1);
	
	var e2xIfc : Interface := getInterfaceFromConnectorCls(e2ConCls);
	
	var e2xOp : Operation := e2xIfc.ownedOperation->asSequence()->at(1);
	
	// Create the ItsXIfc reference array: 
	var foundCount : Integer := e2ConCls[Class].allAttributes()
					->collect(name = IFC_ASSOC_NAME)->count(true);
	
	var e2ItsXIfc : Property;			
	if (foundCount = 0)
	{
		e2ItsXIfc := new Property(IFC_ASSOC_NAME, e2xIfc, 
			OUTPORT_MULTIPLICITY, OUTPORT_MULTIPLICITY);
		e2ConCls.ownedAttribute += e2ItsXIfc;
	}
	else if (foundCount = 1)
	{
		e2ItsXIfc := e2ConCls[Class].allAttributes()
			->select(name = IFC_ASSOC_NAME)->oclAsType(Property)->asSequence()->at(1);
	}
	else
	{
		log("WARNING: property " + IFC_ASSOC_NAME + " is defined more than once under class " + 
			e2ConCls.name);
	};
	
	endLog("Done");
	
	beginLog("Locating fUML model elements");
	
	// locate fUML model elements: ConnectorClass should be under the package named in alf 
	
	var arg2 : String := fUmlModel.rootObjects()[Model].name->asSequence()->at(1);
	
	var fUmlModel : Model := fUmlModel.rootObjects()[Model]->asSequence()->at(1);
	
	var fUmlPkg : Package := fUmlModel.packagedElement
		->select(name = ALF_PKG_NAME)
		->oclAsType(Package)->asSequence()->at(1);
						      
	var fUmlConCls : Class := fUmlPkg.packagedElement
		->select(name = e2ConCls.name)->oclAsType(Class)->asSequence()->at(1);
														
	var fUmlConnectorBehaviorActivity : Activity := findConnectorBehaviorActivity(fUmlConCls);
	
	endLog("Done");
	
	beginLog("Copying fUML activity for connector behavior into e2 model");
	
	var newActivity: Activity = fUmlConnectorBehaviorActivity[Activity]
		->deepclone()->asSequence()->at(1);
	
	e2ConCls.ownedBehavior += newActivity;
	
	// Delete existing method of e2xOp;
	if (e2xOp.method != null)
	{
		e2Model.removeElement(e2xOp.method.oclAsType(Element)->asSequence()->at(1));
	};
	
	// Set specification of the newActivity to xOp in the e2 model. 
	newActivity.specification := e2xOp;
	
	endLog("Done");
	
	beginLog("Fixing unresolved references of connector behavior activity in e2 Model");
	
	var allStuff : Set(Element) := newActivity[Activity]->allOwnedElements()
		->asSequence()->at(1);
	
	var count : Integer := 0; 
	allStuff->forEach(e) {
		
		if (e.oclIsKindOf(StructuralFeatureAction))
		{
			var sfa : StructuralFeatureAction = e.oclAsType(StructuralFeatureAction);
			
			var sfname : String := sfa.structuralFeature.name;
			var sfqualifiedName : String := sfa.structuralFeature.qualifiedName;
			
			var idx : Integer := sfqualifiedName.indexOf(ALF_PKG_NAME);  
			if (idx > 0)
			{
				inlog("Found: StructuralFeatureAction: " + sfqualifiedName);
				count := count + 1; 	
				
				// Now, we should do a name resolution here. 
				// Try to find the structuralFeature in the connectorClass. 
				foundCount := e2ConCls[Class].allAttributes()
					->collect(name = sfname)->count(true);
				
				if (foundCount != 1)
				{ 
					inlog("WARNING: Expected to find exactly 1 attribute with name " + sfname + 
						" under class " + e2ConCls.qualifiedName  + " but found " + 
						foundCount.toString());
				}
				else
				{
					var e2Property : Property := e2ConCls[Class].allAttributes()
						->select(name = sfname)->oclAsType(Property)->asSequence()->at(1);
												 	
					// Now, let's alter the structural feature to this one. 
					sfa.structuralFeature := e2Property;
					inlog("Updated structuralFeature field of StructuralFeatureAction " + 
						sfqualifiedName);
				}
			};   
			
			sfa.input->forEach(inputPin) {
				
				if (inputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0)
				{
					if (inputPin.type.name = e2ConCls.name) 
					{
						inputPin.type := e2ConCls;
						inlog("Updated inputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2ConCls.name);
					}
				}
				else if (inputPin.type.name = e2xIfc.name)
				{
					inputPin.type := e2xIfc;
					inlog("Updated inputPin.type field of StructuralFeatureAction " + 
						sfqualifiedName + " as " + e2xIfc.name);	
				}
			};
			
			sfa.output->forEach(outputPin) {
				
				if (outputPin.type.qualifiedName.indexOf(ALF_PKG_NAME) > 0) 
				{
					if (outputPin.type.name = e2ConCls.name)
					{
						outputPin.type := e2ConCls;
						inlog("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2ConCls.name);
					}
					else if (outputPin.type.name = e2xIfc.name)
					{
						outputPin.type := e2xIfc;
						inlog("Updated outputPin.type field of StructuralFeatureAction " + 
							sfqualifiedName + " as " + e2xIfc.name);	
					}
				}	
			};
			
			
		}
		else if (e.oclIsKindOf(ReadSelfAction)) 
		{
			var rsa : ReadSelfAction := e.oclAsType(ReadSelfAction);
			var rsaResultTypeQualifiedName : String := rsa.result.type.qualifiedName;
			
			if (rsaResultTypeQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: ReadSelfAction result.type: " + rsaResultTypeQualifiedName);
				count := count + 1; 
				
				var rsaResultTypeName : String := rsa.result.type.name;
				
				// Now, should we be specific about it and assume that the type is 
				// of ConnectorCls? 
				// TODO: may require revising
				if (rsaResultTypeName = e2ConCls.name)
				{
					rsa.result.type := e2ConCls;
					inlog("Updated result.type field of ReadSelfAction: " + rsa.name);
				}
			}
		}
		else if (e.oclIsKindOf(CallOperationAction))
		{
			var coa : CallOperationAction := e.oclAsType(CallOperationAction);
			var coaOpQualifiedName = coa.operation.qualifiedName;
			
			if (coaOpQualifiedName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation operation: " + coaOpQualifiedName);
				
				var coaOpName := coa.operation.name;
				
				if (coaOpName = e2xOp.name)
				{
					inlog("Updating operation field of CallOperationAction: " + coa.name);
					coa.operation := e2xOp;
					count := count + 1;
				}
				
			};
			
			var coaTargetTypeQName : String := coa.target.type.qualifiedName;
			 
			if (coaTargetTypeQName.indexOf(ALF_PKG_NAME) > 0)
			{
				inlog("Found: CallOperation target type: " + coaTargetTypeQName);
				
				var coaTargetTypeName : String := coa.target.type.name;
				if (coaTargetTypeName = e2ConCls.name)
				{
					inlog("Updating target.type field of CallOperationAction: " + coa.name +
						" as " + e2xIfc.name);
					coa.target.type := e2ConCls;
					count := count + 1;
				}
				else if (coaTargetTypeName = e2xIfc.name)
				{
					inlog("Updating target.type field of CallOperationAction: " + coa.name + 
						" as " + e2xIfc.name);
					coa.target.type := e2xIfc;
					count := count + 1;
				}
			}
		}
	};
	
	inlog("Replaced " + count.toString() + " references");
	
	endLog("Done");
}


// Find model element represented by the pathStr 
helper getModelElement(pathStr: String, inputModel:uml) : Element
{	
	var allObjects := inputModel.rootObjects().allSubobjects();
	
	allObjects->forEach(e) {
		if (e.oclIsKindOf(NamedElement)->asSequence()->at(1) = true)
		{
			var ne : NamedElement := e->oclAsType(NamedElement)->asSequence()->at(1);
			  
			var elementPath : String := getModelPath(ne);
			
			if (elementPath = pathStr)
			{
				return e->oclAsType(Element)->asSequence()->at(1);
			}	
		}
	};
	
	return null;
}